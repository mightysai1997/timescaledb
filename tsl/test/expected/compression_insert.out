-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
CREATE TABLE test1 (timec timestamptz , i integer ,
      b bigint, t text,  unique ( b, timec));
SELECT table_name from create_hypertable('test1', 'timec', chunk_time_interval=> INTERVAL '7 days');
NOTICE:  adding not-null constraint to column "timec"
 table_name 
------------
 test1
(1 row)

INSERT INTO test1 select q, 10, 11, 'hello' FROM generate_series( '2020-01-03 10:00:00-05', '2020-01-03 12:00:00-05' , '5 min'::interval) q;
---INSERT INTO test1 SELECT '2021-01-01 10:00:00' , i, i *10, 'hello' FROM (Select generate_series(1, 100, 1) i ) q;
ALTER TABLE test1 set (timescaledb.compress, 
timescaledb.compress_segmentby = 'b', 
timescaledb.compress_orderby = 'timec DESC');
--other variants
--ALTER TABLE test1 set (timescaledb.compress, 
--timescaledb.compress_orderby = 'b, timec DESC');
--ALTER TABLE test1 set (timescaledb.compress, 
--timescaledb.compress_orderby = 'timec DESC');
SELECT compress_chunk(c)
FROM show_chunks('test1') c;
             compress_chunk             
----------------------------------------
 _timescaledb_internal._hyper_1_1_chunk
(1 row)

-- single and multi row insert into the compressed chunk --
INSERT INTO test1 SELECT '2020-01-02 11:16:00-05' , i, i +5, 'new' FROM (Select generate_series(11, 12, 1) i ) q;
NOTICE:  (0 0) map (1 timec) to (1 timec) 
NOTICE:  (1 1) map (2 i) to (2 i) 
NOTICE:  (2 2) map (3 b) to (3 b) 
NOTICE:  (3 3) map (4 t) to (4 t) 
NOTICE:  (0 0) map (1 timec) to (1 timec) 
NOTICE:  (1 1) map (2 i) to (2 i) 
NOTICE:  (2 2) map (3 b) to (3 b) 
NOTICE:  (3 3) map (4 t) to (4 t) 
INSERT INTO test1 SELECT '2020-01-02 11:16:00-05' , i, i +5, 'NEW'
FROM (Select generate_series(10, 20, 1) i ) q;
NOTICE:  (0 0) map (1 timec) to (1 timec) 
NOTICE:  (1 1) map (2 i) to (2 i) 
NOTICE:  (2 2) map (3 b) to (3 b) 
NOTICE:  (3 3) map (4 t) to (4 t) 
NOTICE:  (0 0) map (1 timec) to (1 timec) 
NOTICE:  (1 1) map (2 i) to (2 i) 
NOTICE:  (2 2) map (3 b) to (3 b) 
NOTICE:  (3 3) map (4 t) to (4 t) 
NOTICE:  (0 0) map (1 timec) to (1 timec) 
NOTICE:  (1 1) map (2 i) to (2 i) 
NOTICE:  (2 2) map (3 b) to (3 b) 
NOTICE:  (3 3) map (4 t) to (4 t) 
NOTICE:  (0 0) map (1 timec) to (1 timec) 
NOTICE:  (1 1) map (2 i) to (2 i) 
NOTICE:  (2 2) map (3 b) to (3 b) 
NOTICE:  (3 3) map (4 t) to (4 t) 
NOTICE:  (0 0) map (1 timec) to (1 timec) 
NOTICE:  (1 1) map (2 i) to (2 i) 
NOTICE:  (2 2) map (3 b) to (3 b) 
NOTICE:  (3 3) map (4 t) to (4 t) 
NOTICE:  (0 0) map (1 timec) to (1 timec) 
NOTICE:  (1 1) map (2 i) to (2 i) 
NOTICE:  (2 2) map (3 b) to (3 b) 
NOTICE:  (3 3) map (4 t) to (4 t) 
NOTICE:  (0 0) map (1 timec) to (1 timec) 
NOTICE:  (1 1) map (2 i) to (2 i) 
NOTICE:  (2 2) map (3 b) to (3 b) 
NOTICE:  (3 3) map (4 t) to (4 t) 
NOTICE:  (0 0) map (1 timec) to (1 timec) 
NOTICE:  (1 1) map (2 i) to (2 i) 
NOTICE:  (2 2) map (3 b) to (3 b) 
NOTICE:  (3 3) map (4 t) to (4 t) 
NOTICE:  (0 0) map (1 timec) to (1 timec) 
NOTICE:  (1 1) map (2 i) to (2 i) 
NOTICE:  (2 2) map (3 b) to (3 b) 
NOTICE:  (3 3) map (4 t) to (4 t) 
NOTICE:  (0 0) map (1 timec) to (1 timec) 
NOTICE:  (1 1) map (2 i) to (2 i) 
NOTICE:  (2 2) map (3 b) to (3 b) 
NOTICE:  (3 3) map (4 t) to (4 t) 
NOTICE:  (0 0) map (1 timec) to (1 timec) 
NOTICE:  (1 1) map (2 i) to (2 i) 
NOTICE:  (2 2) map (3 b) to (3 b) 
NOTICE:  (3 3) map (4 t) to (4 t) 
SELECT count(*) from test1;
 count 
-------
    38
(1 row)

explain verbose
SELECT * FROM test1 WHERE b = 11;
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_1_chunk  (cost=1.01..1.01 rows=1000 width=26)
   Output: _hyper_1_1_chunk.timec, _hyper_1_1_chunk.i, _hyper_1_1_chunk.b, _hyper_1_1_chunk.t
   ->  Seq Scan on _timescaledb_internal.compress_hyper_2_2_chunk  (cost=0.00..1.01 rows=1 width=124)
         Output: compress_hyper_2_2_chunk._ts_meta_count, compress_hyper_2_2_chunk.timec, compress_hyper_2_2_chunk.i, compress_hyper_2_2_chunk.b, compress_hyper_2_2_chunk.t
         Filter: (compress_hyper_2_2_chunk.b = 11)
(5 rows)

SELECT * FROM test1 WHERE b = 11 order by i, timec ;
            timec             | i  | b  |   t   
------------------------------+----+----+-------
 Fri Jan 03 07:00:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 07:05:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 07:10:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 07:15:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 07:20:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 07:25:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 07:30:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 07:35:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 07:40:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 07:45:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 07:50:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 07:55:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 08:00:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 08:05:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 08:10:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 08:15:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 08:20:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 08:25:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 08:30:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 08:35:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 08:40:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 08:45:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 08:50:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 08:55:00 2020 PST | 10 | 11 | hello
 Fri Jan 03 09:00:00 2020 PST | 10 | 11 | hello
(25 rows)

explain verbose
SELECT * FROM test1 WHERE i = 11;
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_1_chunk  (cost=1.01..1.01 rows=1000 width=26)
   Output: _hyper_1_1_chunk.timec, _hyper_1_1_chunk.i, _hyper_1_1_chunk.b, _hyper_1_1_chunk.t
   Filter: (_hyper_1_1_chunk.i = 11)
   ->  Seq Scan on _timescaledb_internal.compress_hyper_2_2_chunk  (cost=0.00..1.01 rows=1 width=124)
         Output: compress_hyper_2_2_chunk._ts_meta_count, compress_hyper_2_2_chunk.timec, compress_hyper_2_2_chunk.i, compress_hyper_2_2_chunk.b, compress_hyper_2_2_chunk.t
(5 rows)

-- TODO fix this
--SELECT * FROM test1 WHERE i = 11;
--- TESTS for tables with defaults ---
--check sequences , generated etc. ....
--cannot check unique constraints yet
CREATE TABLE test2 (timec timestamptz , 
      i integer CHECK ( i > 10) ,
      b bigint default 20 , 
      t text NOT NULL,  unique ( b, timec),
      CONSTRAINT rowconstr CHECK ( b > i )
);
SELECT table_name from create_hypertable('test2', 'timec', chunk_time_interval=> INTERVAL '7 days');
NOTICE:  adding not-null constraint to column "timec"
 table_name 
------------
 test2
(1 row)

ALTER TABLE test2 set (timescaledb.compress, 
timescaledb.compress_segmentby = 'b', 
timescaledb.compress_orderby = 'timec DESC');
INSERT INTO test2 values('2020-01-02 11:16:00-05' , 100, 105, 'first' );
SELECT compress_chunk(c)
FROM show_chunks('test2') c;
             compress_chunk             
----------------------------------------
 _timescaledb_internal._hyper_3_3_chunk
(1 row)

-- test if default value for b is used
INSERT INTO test2(timec, i, t) values('2020-01-02 10:16:00-05' , 11, 'default' );
NOTICE:  (0 0) map (1 timec) to (1 timec) 
NOTICE:  (1 1) map (2 i) to (2 i) 
NOTICE:  (2 2) map (3 b) to (3 b) 
NOTICE:  (3 3) map (4 t) to (4 t) 
SELECT b from test2 ORDER BY 1;
  b  
-----
  20
 105
(2 rows)

\set ON_ERROR_STOP 0
--null value for t, should fail
INSERT INTO test2 values ( '2020-01-02 01:00:00-05', 100, 200, NULL);
ERROR:  null value in column "t" of relation "_hyper_3_3_chunk" violates not-null constraint
-- i=1, should fail
INSERT INTO test2 values ( '2020-01-02 01:00:00-05', 1, 10, 'null i');
ERROR:  new row for relation "_hyper_3_3_chunk" violates check constraint "test2_i_check"
-- b < i, should fail
INSERT INTO test2 values ( '2020-01-02 01:00:00-05', 22, 1, 'null i');
ERROR:  new row for relation "_hyper_3_3_chunk" violates check constraint "rowconstr"
\set ON_ERROR_STOP 1
--verify we are still inserting into the compressed chunk i.e did not
--create a new chunk
SELECT count(c)
FROM show_chunks('test2') c;
 count 
-------
     1
(1 row)

-- need tests with dropped columns on hypertable and then adding data
-- to chunk

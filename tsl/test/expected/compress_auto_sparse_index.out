-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
create table sparse(ts int, value float);
select create_hypertable('sparse', 'ts');
NOTICE:  adding not-null constraint to column "ts"
  create_hypertable  
---------------------
 (1,public,sparse,t)
(1 row)

insert into sparse select x, x from generate_series(1, 10000) x;
alter table sparse set (timescaledb.compress);
-- When the chunks are compressed, minmax metadata are created for columns that
-- have btree indexes.
create index ii on sparse(value);
select count(compress_chunk(x)) from show_chunks('sparse') x;
 count 
-------
     1
(1 row)

explain select * from sparse where value = 1;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Custom Scan (DecompressChunk) on _hyper_1_1_chunk  (cost=0.27..19.75 rows=72000 width=12)
   Vectorized Filter: (value = '1'::double precision)
   ->  Seq Scan on compress_hyper_2_2_chunk  (cost=0.00..19.75 rows=72 width=76)
         Filter: ((_ts_meta_v2_min_2 <= '1'::double precision) AND (_ts_meta_v2_max_2 >= '1'::double precision))
(4 rows)

-- Not for expression indexes.
drop index ii;
create index ii on sparse((value + 1));
select count(compress_chunk(decompress_chunk(x))) from show_chunks('sparse') x;
 count 
-------
     1
(1 row)

explain select * from sparse where value = 1;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Custom Scan (DecompressChunk) on _hyper_1_1_chunk  (cost=0.02..17.50 rows=750000 width=12)
   Vectorized Filter: (value = '1'::double precision)
   ->  Seq Scan on compress_hyper_2_3_chunk  (cost=0.00..17.50 rows=750 width=76)
(3 rows)

-- Not for other index types.
drop index ii;
create index ii on sparse using hash(value);
select count(compress_chunk(decompress_chunk(x))) from show_chunks('sparse') x;
 count 
-------
     1
(1 row)

explain select * from sparse where value = 1;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Custom Scan (DecompressChunk) on _hyper_1_1_chunk  (cost=0.02..17.50 rows=750000 width=12)
   Vectorized Filter: (value = '1'::double precision)
   ->  Seq Scan on compress_hyper_2_4_chunk  (cost=0.00..17.50 rows=750 width=76)
(3 rows)

-- When the chunk is recompressed without index, no sparse index is created.
drop index ii;
select count(compress_chunk(decompress_chunk(x))) from show_chunks('sparse') x;
 count 
-------
     1
(1 row)

explain select * from sparse where value = 1;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Custom Scan (DecompressChunk) on _hyper_1_1_chunk  (cost=0.02..17.50 rows=750000 width=12)
   Vectorized Filter: (value = '1'::double precision)
   ->  Seq Scan on compress_hyper_2_5_chunk  (cost=0.00..17.50 rows=750 width=76)
(3 rows)


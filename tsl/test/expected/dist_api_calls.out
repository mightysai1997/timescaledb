-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- Basic testing of API functions on distributed hypertable
-- Need to be super user to create extension and add data nodes
\c :TEST_DBNAME :ROLE_CLUSTER_SUPERUSER;
-- Support for execute_sql_and_filter_server_name_on_error()
\unset ECHO
psql:include/remote_exec.sql:5: NOTICE:  schema "test" already exists, skipping
-- Cleanup from other potential tests that created these databases
SET client_min_messages TO ERROR;
DROP DATABASE IF EXISTS data_node_1;
DROP DATABASE IF EXISTS data_node_2;
DROP DATABASE IF EXISTS data_node_3;
SET client_min_messages TO NOTICE;
-- Add data nodes
SELECT * FROM add_data_node('data_node_1', host => 'localhost',
                            database => 'data_node_1');
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_1 | localhost | 55432 | data_node_1 | t            | t                | t
(1 row)

SELECT * FROM add_data_node('data_node_2', host => 'localhost',
                            database => 'data_node_2');
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_2 | localhost | 55432 | data_node_2 | t            | t                | t
(1 row)

SELECT * FROM add_data_node('data_node_3', host => 'localhost',
                            database => 'data_node_3');
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_3 | localhost | 55432 | data_node_3 | t            | t                | t
(1 row)

GRANT USAGE ON FOREIGN SERVER data_node_1, data_node_2, data_node_3 TO PUBLIC;
-- Create a distributed hypertable with data
SET ROLE :ROLE_1;
CREATE TABLE disttable(
    time timestamptz NOT NULL,
    device int,
    value float
);
SELECT * FROM create_distributed_hypertable('disttable', 'time', 'device', 3);
 hypertable_id | schema_name | table_name | created 
---------------+-------------+------------+---------
             1 | public      | disttable  | t
(1 row)

INSERT INTO disttable VALUES
       ('2017-01-01 06:01', 1, 1.2),
       ('2017-01-01 09:11', 3, 4.3),
       ('2017-01-01 08:01', 1, 7.3),
       ('2017-01-02 08:01', 2, 0.23),
       ('2018-07-02 08:01', 87, 0.0),
       ('2018-07-01 06:01', 13, 3.1),
       ('2018-07-01 09:11', 90, 10303.12),
       ('2018-07-01 08:01', 29, 64);
SELECT * FROM disttable ORDER BY time;
             time             | device |  value   
------------------------------+--------+----------
 Sun Jan 01 06:01:00 2017 PST |      1 |      1.2
 Sun Jan 01 08:01:00 2017 PST |      1 |      7.3
 Sun Jan 01 09:11:00 2017 PST |      3 |      4.3
 Mon Jan 02 08:01:00 2017 PST |      2 |     0.23
 Sun Jul 01 06:01:00 2018 PDT |     13 |      3.1
 Sun Jul 01 08:01:00 2018 PDT |     29 |       64
 Sun Jul 01 09:11:00 2018 PDT |     90 | 10303.12
 Mon Jul 02 08:01:00 2018 PDT |     87 |        0
(8 rows)

SELECT * FROM test.remote_exec(NULL, $$ SELECT show_chunks('disttable'); $$);
NOTICE:  [data_node_1]:  SELECT show_chunks('disttable')
NOTICE:  [data_node_1]:
show_chunks                                
-------------------------------------------
_timescaledb_internal._dist_hyper_1_1_chunk
_timescaledb_internal._dist_hyper_1_4_chunk
(2 rows)


NOTICE:  [data_node_2]:  SELECT show_chunks('disttable')
NOTICE:  [data_node_2]:
show_chunks                                
-------------------------------------------
_timescaledb_internal._dist_hyper_1_3_chunk
_timescaledb_internal._dist_hyper_1_5_chunk
(2 rows)


NOTICE:  [data_node_3]:  SELECT show_chunks('disttable')
NOTICE:  [data_node_3]:
show_chunks                                
-------------------------------------------
_timescaledb_internal._dist_hyper_1_2_chunk
_timescaledb_internal._dist_hyper_1_6_chunk
(2 rows)


 remote_exec 
-------------
 
(1 row)

-- Test APIs on the distributed hypertable
-- Call drop_chunks
SELECT drop_chunks('disttable', timestamptz '2017-03-01 00:00');
                 drop_chunks                 
---------------------------------------------
 _timescaledb_internal._dist_hyper_1_1_chunk
 _timescaledb_internal._dist_hyper_1_2_chunk
 _timescaledb_internal._dist_hyper_1_3_chunk
(3 rows)

SELECT * FROM disttable ORDER BY time;
             time             | device |  value   
------------------------------+--------+----------
 Sun Jul 01 06:01:00 2018 PDT |     13 |      3.1
 Sun Jul 01 08:01:00 2018 PDT |     29 |       64
 Sun Jul 01 09:11:00 2018 PDT |     90 | 10303.12
 Mon Jul 02 08:01:00 2018 PDT |     87 |        0
(4 rows)

SELECT * FROM test.remote_exec(NULL, $$ SELECT show_chunks('disttable'); $$);
NOTICE:  [data_node_1]:  SELECT show_chunks('disttable')
NOTICE:  [data_node_1]:
show_chunks                                
-------------------------------------------
_timescaledb_internal._dist_hyper_1_4_chunk
(1 row)


NOTICE:  [data_node_2]:  SELECT show_chunks('disttable')
NOTICE:  [data_node_2]:
show_chunks                                
-------------------------------------------
_timescaledb_internal._dist_hyper_1_5_chunk
(1 row)


NOTICE:  [data_node_3]:  SELECT show_chunks('disttable')
NOTICE:  [data_node_3]:
show_chunks                                
-------------------------------------------
_timescaledb_internal._dist_hyper_1_6_chunk
(1 row)


 remote_exec 
-------------
 
(1 row)

-- Restore the state
INSERT INTO disttable VALUES
       ('2017-01-01 06:01', 1, 1.2),
       ('2017-01-01 09:11', 3, 4.3),
       ('2017-01-01 08:01', 1, 7.3),
       ('2017-01-02 08:01', 2, 0.23);
SELECT * FROM disttable ORDER BY time;
             time             | device |  value   
------------------------------+--------+----------
 Sun Jan 01 06:01:00 2017 PST |      1 |      1.2
 Sun Jan 01 08:01:00 2017 PST |      1 |      7.3
 Sun Jan 01 09:11:00 2017 PST |      3 |      4.3
 Mon Jan 02 08:01:00 2017 PST |      2 |     0.23
 Sun Jul 01 06:01:00 2018 PDT |     13 |      3.1
 Sun Jul 01 08:01:00 2018 PDT |     29 |       64
 Sun Jul 01 09:11:00 2018 PDT |     90 | 10303.12
 Mon Jul 02 08:01:00 2018 PDT |     87 |        0
(8 rows)

SELECT * FROM show_chunks('disttable');
                 show_chunks                 
---------------------------------------------
 _timescaledb_internal._dist_hyper_1_4_chunk
 _timescaledb_internal._dist_hyper_1_5_chunk
 _timescaledb_internal._dist_hyper_1_6_chunk
 _timescaledb_internal._dist_hyper_1_7_chunk
 _timescaledb_internal._dist_hyper_1_8_chunk
 _timescaledb_internal._dist_hyper_1_9_chunk
(6 rows)

SELECT * FROM test.remote_exec(NULL, $$ SELECT show_chunks('disttable'); $$);
NOTICE:  [data_node_1]:  SELECT show_chunks('disttable')
NOTICE:  [data_node_1]:
show_chunks                                
-------------------------------------------
_timescaledb_internal._dist_hyper_1_4_chunk
_timescaledb_internal._dist_hyper_1_7_chunk
(2 rows)


NOTICE:  [data_node_2]:  SELECT show_chunks('disttable')
NOTICE:  [data_node_2]:
show_chunks                                
-------------------------------------------
_timescaledb_internal._dist_hyper_1_5_chunk
_timescaledb_internal._dist_hyper_1_9_chunk
(2 rows)


NOTICE:  [data_node_3]:  SELECT show_chunks('disttable')
NOTICE:  [data_node_3]:
show_chunks                                
-------------------------------------------
_timescaledb_internal._dist_hyper_1_6_chunk
_timescaledb_internal._dist_hyper_1_8_chunk
(2 rows)


 remote_exec 
-------------
 
(1 row)

-- Simple test of time_bucket_gapfill
SELECT time_bucket_gapfill('3 hours', time, '2017-01-01 06:00', '2017-01-02 18:00'),
       first(value, time),
       avg(value)
FROM disttable
GROUP BY 1;
     time_bucket_gapfill      | first |   avg   
------------------------------+-------+---------
 Sun Jan 01 04:00:00 2017 PST |   1.2 |     1.2
 Sun Jan 01 07:00:00 2017 PST |   7.3 |     5.8
 Sun Jan 01 10:00:00 2017 PST |       |        
 Sun Jan 01 13:00:00 2017 PST |       |        
 Sun Jan 01 16:00:00 2017 PST |       |        
 Sun Jan 01 19:00:00 2017 PST |       |        
 Sun Jan 01 22:00:00 2017 PST |       |        
 Mon Jan 02 01:00:00 2017 PST |       |        
 Mon Jan 02 04:00:00 2017 PST |       |        
 Mon Jan 02 07:00:00 2017 PST |  0.23 |    0.23
 Mon Jan 02 10:00:00 2017 PST |       |        
 Mon Jan 02 13:00:00 2017 PST |       |        
 Mon Jan 02 16:00:00 2017 PST |       |        
 Sun Jul 01 05:00:00 2018 PDT |   3.1 |     3.1
 Sun Jul 01 08:00:00 2018 PDT |    64 | 5183.56
 Mon Jul 02 08:00:00 2018 PDT |     0 |       0
(16 rows)

SELECT time_bucket_gapfill('3 hours', time, '2017-01-01 06:00', '2017-01-01 18:00'),
       device,
       first(value, time),
       avg(value)
FROM disttable
GROUP BY 1,2;
     time_bucket_gapfill      | device |  first   |   avg    
------------------------------+--------+----------+----------
 Sun Jan 01 04:00:00 2017 PST |      1 |      1.2 |      1.2
 Sun Jan 01 07:00:00 2017 PST |      1 |      7.3 |      7.3
 Sun Jan 01 10:00:00 2017 PST |      1 |          |         
 Sun Jan 01 13:00:00 2017 PST |      1 |          |         
 Sun Jan 01 16:00:00 2017 PST |      1 |          |         
 Sun Jan 01 04:00:00 2017 PST |      2 |          |         
 Sun Jan 01 07:00:00 2017 PST |      2 |          |         
 Sun Jan 01 10:00:00 2017 PST |      2 |          |         
 Sun Jan 01 13:00:00 2017 PST |      2 |          |         
 Sun Jan 01 16:00:00 2017 PST |      2 |          |         
 Mon Jan 02 07:00:00 2017 PST |      2 |     0.23 |     0.23
 Sun Jan 01 04:00:00 2017 PST |      3 |          |         
 Sun Jan 01 07:00:00 2017 PST |      3 |      4.3 |      4.3
 Sun Jan 01 10:00:00 2017 PST |      3 |          |         
 Sun Jan 01 13:00:00 2017 PST |      3 |          |         
 Sun Jan 01 16:00:00 2017 PST |      3 |          |         
 Sun Jan 01 04:00:00 2017 PST |     13 |          |         
 Sun Jan 01 07:00:00 2017 PST |     13 |          |         
 Sun Jan 01 10:00:00 2017 PST |     13 |          |         
 Sun Jan 01 13:00:00 2017 PST |     13 |          |         
 Sun Jan 01 16:00:00 2017 PST |     13 |          |         
 Sun Jul 01 05:00:00 2018 PDT |     13 |      3.1 |      3.1
 Sun Jan 01 04:00:00 2017 PST |     29 |          |         
 Sun Jan 01 07:00:00 2017 PST |     29 |          |         
 Sun Jan 01 10:00:00 2017 PST |     29 |          |         
 Sun Jan 01 13:00:00 2017 PST |     29 |          |         
 Sun Jan 01 16:00:00 2017 PST |     29 |          |         
 Sun Jul 01 08:00:00 2018 PDT |     29 |       64 |       64
 Sun Jan 01 04:00:00 2017 PST |     87 |          |         
 Sun Jan 01 07:00:00 2017 PST |     87 |          |         
 Sun Jan 01 10:00:00 2017 PST |     87 |          |         
 Sun Jan 01 13:00:00 2017 PST |     87 |          |         
 Sun Jan 01 16:00:00 2017 PST |     87 |          |         
 Mon Jul 02 08:00:00 2018 PDT |     87 |        0 |        0
 Sun Jan 01 04:00:00 2017 PST |     90 |          |         
 Sun Jan 01 07:00:00 2017 PST |     90 |          |         
 Sun Jan 01 10:00:00 2017 PST |     90 |          |         
 Sun Jan 01 13:00:00 2017 PST |     90 |          |         
 Sun Jan 01 16:00:00 2017 PST |     90 |          |         
 Sun Jul 01 08:00:00 2018 PDT |     90 | 10303.12 | 10303.12
(40 rows)

-- Explain the same simple queries with time_bucket_gapfill
EXPLAIN (verbose, costs off)
SELECT time_bucket_gapfill('3 hours', time, '2017-01-01 06:00', '2017-01-02 18:00'),
       first(value, time),
       avg(value)
FROM disttable
GROUP BY 1;
                                                                                                                                QUERY PLAN                                                                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GapFill)
   Output: (time_bucket_gapfill('@ 3 hours'::interval, "time")), (first(value, "time")), (avg(value))
   ->  Sort
         Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone)), (first(disttable.value, disttable."time")), (avg(disttable.value))
         Sort Key: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone))
         ->  HashAggregate
               Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone)), first(disttable.value, disttable."time"), avg(disttable.value)
               Group Key: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone))
               ->  Append
                     ->  Custom Scan (DataNodeScan) on public.disttable
                           Output: time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone), disttable.value, disttable."time"
                           Data node: data_node_1
                           Chunks: _dist_hyper_1_4_chunk, _dist_hyper_1_7_chunk
                           Remote SQL: SELECT "time", value FROM public.disttable WHERE _timescaledb_internal.chunks_in(public.disttable.*, ARRAY[2, 3])
                     ->  Custom Scan (DataNodeScan) on public.disttable disttable_1
                           Output: time_bucket_gapfill('@ 3 hours'::interval, disttable_1."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone), disttable_1.value, disttable_1."time"
                           Data node: data_node_2
                           Chunks: _dist_hyper_1_5_chunk, _dist_hyper_1_9_chunk
                           Remote SQL: SELECT "time", value FROM public.disttable WHERE _timescaledb_internal.chunks_in(public.disttable.*, ARRAY[2, 3])
                     ->  Custom Scan (DataNodeScan) on public.disttable disttable_2
                           Output: time_bucket_gapfill('@ 3 hours'::interval, disttable_2."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone), disttable_2.value, disttable_2."time"
                           Data node: data_node_3
                           Chunks: _dist_hyper_1_6_chunk, _dist_hyper_1_8_chunk
                           Remote SQL: SELECT "time", value FROM public.disttable WHERE _timescaledb_internal.chunks_in(public.disttable.*, ARRAY[2, 3])
(24 rows)

EXPLAIN (verbose, costs off)
SELECT time_bucket_gapfill('3 hours', time, '2017-01-01 06:00', '2017-01-01 18:00'),
       device,
       first(value, time),
       avg(value)
FROM disttable
GROUP BY 1,2;
                                                                                                                                         QUERY PLAN                                                                                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GapFill)
   Output: (time_bucket_gapfill('@ 3 hours'::interval, "time")), device, (first(value, "time")), (avg(value))
   ->  Sort
         Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable.device, (first(disttable.value, disttable."time")), (avg(disttable.value))
         Sort Key: disttable.device, (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone))
         ->  GroupAggregate
               Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable.device, first(disttable.value, disttable."time"), avg(disttable.value)
               Group Key: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable.device
               ->  Sort
                     Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable.device, disttable.value, disttable."time"
                     Sort Key: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable.device
                     ->  Append
                           ->  Custom Scan (DataNodeScan) on public.disttable
                                 Output: time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone), disttable.device, disttable.value, disttable."time"
                                 Data node: data_node_1
                                 Chunks: _dist_hyper_1_4_chunk, _dist_hyper_1_7_chunk
                                 Remote SQL: SELECT "time", device, value FROM public.disttable WHERE _timescaledb_internal.chunks_in(public.disttable.*, ARRAY[2, 3])
                           ->  Custom Scan (DataNodeScan) on public.disttable disttable_1
                                 Output: time_bucket_gapfill('@ 3 hours'::interval, disttable_1."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone), disttable_1.device, disttable_1.value, disttable_1."time"
                                 Data node: data_node_2
                                 Chunks: _dist_hyper_1_5_chunk, _dist_hyper_1_9_chunk
                                 Remote SQL: SELECT "time", device, value FROM public.disttable WHERE _timescaledb_internal.chunks_in(public.disttable.*, ARRAY[2, 3])
                           ->  Custom Scan (DataNodeScan) on public.disttable disttable_2
                                 Output: time_bucket_gapfill('@ 3 hours'::interval, disttable_2."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone), disttable_2.device, disttable_2.value, disttable_2."time"
                                 Data node: data_node_3
                                 Chunks: _dist_hyper_1_6_chunk, _dist_hyper_1_8_chunk
                                 Remote SQL: SELECT "time", device, value FROM public.disttable WHERE _timescaledb_internal.chunks_in(public.disttable.*, ARRAY[2, 3])
(27 rows)

-- Test the same queries with enabled partitionwise aggregate
SET enable_partitionwise_aggregate = 'on';
SELECT time_bucket_gapfill('3 hours', time, '2017-01-01 06:00', '2017-01-02 18:00'),
       first(value, time),
       avg(value)
FROM disttable
GROUP BY 1;
     time_bucket_gapfill      | first |   avg   
------------------------------+-------+---------
 Sun Jan 01 04:00:00 2017 PST |   1.2 |     1.2
 Sun Jan 01 07:00:00 2017 PST |   7.3 |     5.8
 Sun Jan 01 10:00:00 2017 PST |       |        
 Sun Jan 01 13:00:00 2017 PST |       |        
 Sun Jan 01 16:00:00 2017 PST |       |        
 Sun Jan 01 19:00:00 2017 PST |       |        
 Sun Jan 01 22:00:00 2017 PST |       |        
 Mon Jan 02 01:00:00 2017 PST |       |        
 Mon Jan 02 04:00:00 2017 PST |       |        
 Mon Jan 02 07:00:00 2017 PST |  0.23 |    0.23
 Mon Jan 02 10:00:00 2017 PST |       |        
 Mon Jan 02 13:00:00 2017 PST |       |        
 Mon Jan 02 16:00:00 2017 PST |       |        
 Sun Jul 01 05:00:00 2018 PDT |   3.1 |     3.1
 Sun Jul 01 08:00:00 2018 PDT |    64 | 5183.56
 Mon Jul 02 08:00:00 2018 PDT |     0 |       0
(16 rows)

SELECT time_bucket_gapfill('3 hours', time, '2017-01-01 06:00', '2017-01-01 18:00'),
       device,
       first(value, time),
       avg(value)
FROM disttable
GROUP BY 1,2;
     time_bucket_gapfill      | device |  first   |   avg    
------------------------------+--------+----------+----------
 Sun Jan 01 04:00:00 2017 PST |      1 |      1.2 |      1.2
 Sun Jan 01 07:00:00 2017 PST |      1 |      7.3 |      7.3
 Sun Jan 01 10:00:00 2017 PST |      1 |          |         
 Sun Jan 01 13:00:00 2017 PST |      1 |          |         
 Sun Jan 01 16:00:00 2017 PST |      1 |          |         
 Sun Jan 01 04:00:00 2017 PST |      2 |          |         
 Sun Jan 01 07:00:00 2017 PST |      2 |          |         
 Sun Jan 01 10:00:00 2017 PST |      2 |          |         
 Sun Jan 01 13:00:00 2017 PST |      2 |          |         
 Sun Jan 01 16:00:00 2017 PST |      2 |          |         
 Mon Jan 02 07:00:00 2017 PST |      2 |     0.23 |     0.23
 Sun Jan 01 04:00:00 2017 PST |      3 |          |         
 Sun Jan 01 07:00:00 2017 PST |      3 |      4.3 |      4.3
 Sun Jan 01 10:00:00 2017 PST |      3 |          |         
 Sun Jan 01 13:00:00 2017 PST |      3 |          |         
 Sun Jan 01 16:00:00 2017 PST |      3 |          |         
 Sun Jan 01 04:00:00 2017 PST |     13 |          |         
 Sun Jan 01 07:00:00 2017 PST |     13 |          |         
 Sun Jan 01 10:00:00 2017 PST |     13 |          |         
 Sun Jan 01 13:00:00 2017 PST |     13 |          |         
 Sun Jan 01 16:00:00 2017 PST |     13 |          |         
 Sun Jul 01 05:00:00 2018 PDT |     13 |      3.1 |      3.1
 Sun Jan 01 04:00:00 2017 PST |     29 |          |         
 Sun Jan 01 07:00:00 2017 PST |     29 |          |         
 Sun Jan 01 10:00:00 2017 PST |     29 |          |         
 Sun Jan 01 13:00:00 2017 PST |     29 |          |         
 Sun Jan 01 16:00:00 2017 PST |     29 |          |         
 Sun Jul 01 08:00:00 2018 PDT |     29 |       64 |       64
 Sun Jan 01 04:00:00 2017 PST |     87 |          |         
 Sun Jan 01 07:00:00 2017 PST |     87 |          |         
 Sun Jan 01 10:00:00 2017 PST |     87 |          |         
 Sun Jan 01 13:00:00 2017 PST |     87 |          |         
 Sun Jan 01 16:00:00 2017 PST |     87 |          |         
 Mon Jul 02 08:00:00 2018 PDT |     87 |        0 |        0
 Sun Jan 01 04:00:00 2017 PST |     90 |          |         
 Sun Jan 01 07:00:00 2017 PST |     90 |          |         
 Sun Jan 01 10:00:00 2017 PST |     90 |          |         
 Sun Jan 01 13:00:00 2017 PST |     90 |          |         
 Sun Jan 01 16:00:00 2017 PST |     90 |          |         
 Sun Jul 01 08:00:00 2018 PDT |     90 | 10303.12 | 10303.12
(40 rows)

-- Explain the same simple queries with time_bucket_gapfill
EXPLAIN (verbose, costs off)
SELECT time_bucket_gapfill('3 hours', time, '2017-01-01 06:00', '2017-01-02 18:00'),
       first(value, time),
       avg(value)
FROM disttable
GROUP BY 1;
                                                                                                                                                  QUERY PLAN                                                                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GapFill)
   Output: (time_bucket_gapfill('@ 3 hours'::interval, "time")), (first(value, "time")), (avg(value))
   ->  Finalize GroupAggregate
         Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone)), first(disttable.value, disttable."time"), avg(disttable.value)
         Group Key: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone))
         ->  Sort
               Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone)), (PARTIAL first(disttable.value, disttable."time")), (PARTIAL avg(disttable.value))
               Sort Key: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone))
               ->  Append
                     ->  Partial HashAggregate
                           Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone)), PARTIAL first(disttable.value, disttable."time"), PARTIAL avg(disttable.value)
                           Group Key: time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone)
                           ->  Custom Scan (DataNodeScan) on public.disttable
                                 Output: time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone), disttable.value, disttable."time"
                                 Data node: data_node_1
                                 Chunks: _dist_hyper_1_4_chunk, _dist_hyper_1_7_chunk
                                 Remote SQL: SELECT "time", value FROM public.disttable WHERE _timescaledb_internal.chunks_in(public.disttable.*, ARRAY[2, 3])
                     ->  Partial HashAggregate
                           Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable_1."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone)), PARTIAL first(disttable_1.value, disttable_1."time"), PARTIAL avg(disttable_1.value)
                           Group Key: time_bucket_gapfill('@ 3 hours'::interval, disttable_1."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone)
                           ->  Custom Scan (DataNodeScan) on public.disttable disttable_1
                                 Output: time_bucket_gapfill('@ 3 hours'::interval, disttable_1."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone), disttable_1.value, disttable_1."time"
                                 Data node: data_node_2
                                 Chunks: _dist_hyper_1_5_chunk, _dist_hyper_1_9_chunk
                                 Remote SQL: SELECT "time", value FROM public.disttable WHERE _timescaledb_internal.chunks_in(public.disttable.*, ARRAY[2, 3])
                     ->  Partial HashAggregate
                           Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable_2."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone)), PARTIAL first(disttable_2.value, disttable_2."time"), PARTIAL avg(disttable_2.value)
                           Group Key: time_bucket_gapfill('@ 3 hours'::interval, disttable_2."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone)
                           ->  Custom Scan (DataNodeScan) on public.disttable disttable_2
                                 Output: time_bucket_gapfill('@ 3 hours'::interval, disttable_2."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Mon Jan 02 18:00:00 2017 PST'::timestamp with time zone), disttable_2.value, disttable_2."time"
                                 Data node: data_node_3
                                 Chunks: _dist_hyper_1_6_chunk, _dist_hyper_1_8_chunk
                                 Remote SQL: SELECT "time", value FROM public.disttable WHERE _timescaledb_internal.chunks_in(public.disttable.*, ARRAY[2, 3])
(33 rows)

EXPLAIN (verbose, costs off)
SELECT time_bucket_gapfill('3 hours', time, '2017-01-01 06:00', '2017-01-01 18:00'),
       device,
       first(value, time),
       avg(value)
FROM disttable
GROUP BY 1,2;
                                                                                                                                                            QUERY PLAN                                                                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GapFill)
   Output: (time_bucket_gapfill('@ 3 hours'::interval, "time")), device, (first(value, "time")), (avg(value))
   ->  Sort
         Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable.device, (first(disttable.value, disttable."time")), (avg(disttable.value))
         Sort Key: disttable.device, (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone))
         ->  Finalize GroupAggregate
               Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable.device, first(disttable.value, disttable."time"), avg(disttable.value)
               Group Key: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable.device
               ->  Merge Append
                     Sort Key: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable.device
                     ->  Partial GroupAggregate
                           Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable.device, PARTIAL first(disttable.value, disttable."time"), PARTIAL avg(disttable.value)
                           Group Key: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable.device
                           ->  Sort
                                 Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable.device, disttable.value, disttable."time"
                                 Sort Key: (time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable.device
                                 ->  Custom Scan (DataNodeScan) on public.disttable
                                       Output: time_bucket_gapfill('@ 3 hours'::interval, disttable."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone), disttable.device, disttable.value, disttable."time"
                                       Data node: data_node_1
                                       Chunks: _dist_hyper_1_4_chunk, _dist_hyper_1_7_chunk
                                       Remote SQL: SELECT "time", device, value FROM public.disttable WHERE _timescaledb_internal.chunks_in(public.disttable.*, ARRAY[2, 3])
                     ->  Partial GroupAggregate
                           Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable_1."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable_1.device, PARTIAL first(disttable_1.value, disttable_1."time"), PARTIAL avg(disttable_1.value)
                           Group Key: (time_bucket_gapfill('@ 3 hours'::interval, disttable_1."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable_1.device
                           ->  Sort
                                 Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable_1."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable_1.device, disttable_1.value, disttable_1."time"
                                 Sort Key: (time_bucket_gapfill('@ 3 hours'::interval, disttable_1."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable_1.device
                                 ->  Custom Scan (DataNodeScan) on public.disttable disttable_1
                                       Output: time_bucket_gapfill('@ 3 hours'::interval, disttable_1."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone), disttable_1.device, disttable_1.value, disttable_1."time"
                                       Data node: data_node_2
                                       Chunks: _dist_hyper_1_5_chunk, _dist_hyper_1_9_chunk
                                       Remote SQL: SELECT "time", device, value FROM public.disttable WHERE _timescaledb_internal.chunks_in(public.disttable.*, ARRAY[2, 3])
                     ->  Partial GroupAggregate
                           Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable_2."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable_2.device, PARTIAL first(disttable_2.value, disttable_2."time"), PARTIAL avg(disttable_2.value)
                           Group Key: (time_bucket_gapfill('@ 3 hours'::interval, disttable_2."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable_2.device
                           ->  Sort
                                 Output: (time_bucket_gapfill('@ 3 hours'::interval, disttable_2."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable_2.device, disttable_2.value, disttable_2."time"
                                 Sort Key: (time_bucket_gapfill('@ 3 hours'::interval, disttable_2."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone)), disttable_2.device
                                 ->  Custom Scan (DataNodeScan) on public.disttable disttable_2
                                       Output: time_bucket_gapfill('@ 3 hours'::interval, disttable_2."time", 'Sun Jan 01 06:00:00 2017 PST'::timestamp with time zone, 'Sun Jan 01 18:00:00 2017 PST'::timestamp with time zone), disttable_2.device, disttable_2.value, disttable_2."time"
                                       Data node: data_node_3
                                       Chunks: _dist_hyper_1_6_chunk, _dist_hyper_1_8_chunk
                                       Remote SQL: SELECT "time", device, value FROM public.disttable WHERE _timescaledb_internal.chunks_in(public.disttable.*, ARRAY[2, 3])
(43 rows)

SET enable_partitionwise_aggregate = 'off';
-- Ensure that move_chunk() and reorder_chunk() functions cannot be used
-- with distributed hypertable
SET ROLE TO DEFAULT;
SET client_min_messages TO error;
DROP TABLESPACE IF EXISTS tablespace1;
RESET client_min_messages;
CREATE TABLESPACE tablespace1 OWNER :ROLE_CLUSTER_SUPERUSER LOCATION :TEST_TABLESPACE1_PATH;
\set ON_ERROR_STOP 0
SELECT move_chunk(chunk=>'_timescaledb_internal._dist_hyper_1_4_chunk', destination_tablespace=>'tablespace1', index_destination_tablespace=>'tablespace1', reorder_index=>'disttable_time_idx', verbose=>TRUE);
WARNING:  Timescale License expired
ERROR:  move_chunk() and reorder_chunk() cannot be used with distributed hypertables
SELECT reorder_chunk('_timescaledb_internal._dist_hyper_1_4_chunk', verbose => TRUE);
ERROR:  move_chunk() and reorder_chunk() cannot be used with distributed hypertables
\set ON_ERROR_STOP 1
DROP TABLESPACE tablespace1;
-- Ensure approximate_row_count() works with distributed hypertable
--
SELECT * FROM disttable ORDER BY time;
             time             | device |  value   
------------------------------+--------+----------
 Sun Jan 01 06:01:00 2017 PST |      1 |      1.2
 Sun Jan 01 08:01:00 2017 PST |      1 |      7.3
 Sun Jan 01 09:11:00 2017 PST |      3 |      4.3
 Mon Jan 02 08:01:00 2017 PST |      2 |     0.23
 Sun Jul 01 06:01:00 2018 PDT |     13 |      3.1
 Sun Jul 01 08:01:00 2018 PDT |     29 |       64
 Sun Jul 01 09:11:00 2018 PDT |     90 | 10303.12
 Mon Jul 02 08:01:00 2018 PDT |     87 |        0
(8 rows)

ANALYZE disttable;
SELECT count(*) FROM disttable;
 count 
-------
     8
(1 row)

SELECT approximate_row_count('disttable');
 approximate_row_count 
-----------------------
                     8
(1 row)

SELECT * FROM test.remote_exec(NULL, $$ SELECT approximate_row_count('disttable'); $$);
NOTICE:  [data_node_1]:  SELECT approximate_row_count('disttable')
NOTICE:  [data_node_1]:
approximate_row_count
---------------------
                    3
(1 row)


NOTICE:  [data_node_2]:  SELECT approximate_row_count('disttable')
NOTICE:  [data_node_2]:
approximate_row_count
---------------------
                    2
(1 row)


NOTICE:  [data_node_3]:  SELECT approximate_row_count('disttable')
NOTICE:  [data_node_3]:
approximate_row_count
---------------------
                    3
(1 row)


 remote_exec 
-------------
 
(1 row)

-- Test with native replication
--
CREATE TABLE disttable_repl(
    time timestamptz NOT NULL, 
    device int, 
    value float
);
SELECT * FROM create_distributed_hypertable('disttable_repl', 'time', 'device', 3, replication_factor => 2);
 hypertable_id | schema_name |   table_name   | created 
---------------+-------------+----------------+---------
             2 | public      | disttable_repl | t
(1 row)

INSERT INTO disttable_repl VALUES
       ('2017-01-01 06:01', 1, 1.2),
       ('2017-01-01 09:11', 3, 4.3),
       ('2017-01-01 08:01', 1, 7.3),
       ('2017-01-02 08:01', 2, 0.23),
       ('2018-07-02 08:01', 87, 0.0),
       ('2018-07-01 06:01', 13, 3.1),
       ('2018-07-01 09:11', 90, 10303.12),
       ('2018-07-01 08:01', 29, 64);
SELECT * FROM disttable_repl ORDER BY time;
             time             | device |  value   
------------------------------+--------+----------
 Sun Jan 01 06:01:00 2017 PST |      1 |      1.2
 Sun Jan 01 08:01:00 2017 PST |      1 |      7.3
 Sun Jan 01 09:11:00 2017 PST |      3 |      4.3
 Mon Jan 02 08:01:00 2017 PST |      2 |     0.23
 Sun Jul 01 06:01:00 2018 PDT |     13 |      3.1
 Sun Jul 01 08:01:00 2018 PDT |     29 |       64
 Sun Jul 01 09:11:00 2018 PDT |     90 | 10303.12
 Mon Jul 02 08:01:00 2018 PDT |     87 |        0
(8 rows)

SELECT * FROM show_chunks('disttable_repl');
                 show_chunks                  
----------------------------------------------
 _timescaledb_internal._dist_hyper_2_10_chunk
 _timescaledb_internal._dist_hyper_2_11_chunk
 _timescaledb_internal._dist_hyper_2_12_chunk
 _timescaledb_internal._dist_hyper_2_13_chunk
 _timescaledb_internal._dist_hyper_2_14_chunk
 _timescaledb_internal._dist_hyper_2_15_chunk
(6 rows)

SELECT * FROM test.remote_exec(NULL, $$ SELECT show_chunks('disttable_repl'); $$);
NOTICE:  [data_node_1]:  SELECT show_chunks('disttable_repl')
NOTICE:  [data_node_1]:
show_chunks                                 
--------------------------------------------
_timescaledb_internal._dist_hyper_2_10_chunk
_timescaledb_internal._dist_hyper_2_11_chunk
_timescaledb_internal._dist_hyper_2_13_chunk
_timescaledb_internal._dist_hyper_2_15_chunk
(4 rows)


NOTICE:  [data_node_2]:  SELECT show_chunks('disttable_repl')
NOTICE:  [data_node_2]:
show_chunks                                 
--------------------------------------------
_timescaledb_internal._dist_hyper_2_10_chunk
_timescaledb_internal._dist_hyper_2_12_chunk
_timescaledb_internal._dist_hyper_2_13_chunk
_timescaledb_internal._dist_hyper_2_14_chunk
(4 rows)


NOTICE:  [data_node_3]:  SELECT show_chunks('disttable_repl')
NOTICE:  [data_node_3]:
show_chunks                                 
--------------------------------------------
_timescaledb_internal._dist_hyper_2_11_chunk
_timescaledb_internal._dist_hyper_2_12_chunk
_timescaledb_internal._dist_hyper_2_14_chunk
_timescaledb_internal._dist_hyper_2_15_chunk
(4 rows)


 remote_exec 
-------------
 
(1 row)

SELECT count(*) FROM disttable_repl;
 count 
-------
     8
(1 row)

SELECT approximate_row_count('disttable_repl');
 approximate_row_count 
-----------------------
                     0
(1 row)

ANALYZE disttable_repl;
SELECT approximate_row_count('disttable_repl');
 approximate_row_count 
-----------------------
                     8
(1 row)

DROP TABLE disttable_repl;

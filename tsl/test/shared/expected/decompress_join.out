-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
set work_mem to '256MB';
-- disable memoize on PG14+
SELECT CASE WHEN current_setting('server_version_num')::int/10000 >= 14 THEN set_config('enable_memoize','off',false) ELSE 'off' END AS enable_memoize;
 enable_memoize 
 off
(1 row)

SET enable_indexscan TO false;
-- test join on compressed time column
-- #3079, #4465
CREATE TABLE compressed_join_temp AS SELECT * FROM metrics ORDER BY time DESC LIMIT 10;
ANALYZE compressed_join_temp;
EXPLAIN (analyze,costs off,timing off,summary off) SELECT *
FROM compressed_join_temp t
INNER JOIN metrics_compressed m ON t.time = m.time AND t.device_id = m.device_id
ORDER BY t.device_id, t.time
LIMIT 1;
QUERY PLAN
 Limit (actual rows=1 loops=1)
   ->  Merge Join (actual rows=1 loops=1)
         Merge Cond: ((m_1.device_id = t.device_id) AND (m_1."time" = t."time"))
         ->  Merge Append (actual rows=82038 loops=1)
               Sort Key: m_1.device_id, m_1."time"
               ->  Custom Scan (DecompressChunk) on _hyper_X_X_chunk m_1 (actual rows=21587 loops=1)
                     ->  Sort (actual rows=23 loops=1)
                           Sort Key: compress_hyper_X_X_chunk.device_id, compress_hyper_X_X_chunk._ts_meta_sequence_num DESC
                           Sort Method: quicksort 
                           ->  Seq Scan on compress_hyper_X_X_chunk (actual rows=220 loops=1)
               ->  Custom Scan (DecompressChunk) on _hyper_X_X_chunk m_2 (actual rows=30227 loops=1)
                     ->  Sort (actual rows=32 loops=1)
                           Sort Key: compress_hyper_X_X_chunk.device_id, compress_hyper_X_X_chunk._ts_meta_sequence_num DESC
                           Sort Method: quicksort 
                           ->  Seq Scan on compress_hyper_X_X_chunk (actual rows=310 loops=1)
               ->  Custom Scan (DecompressChunk) on _hyper_X_X_chunk m_3 (actual rows=30226 loops=1)
                     ->  Sort (actual rows=31 loops=1)
                           Sort Key: compress_hyper_X_X_chunk.device_id, compress_hyper_X_X_chunk._ts_meta_sequence_num DESC
                           Sort Method: quicksort 
                           ->  Seq Scan on compress_hyper_X_X_chunk (actual rows=310 loops=1)
         ->  Sort (actual rows=1 loops=1)
               Sort Key: t.device_id, t."time"
               Sort Method: quicksort 
               ->  Seq Scan on compressed_join_temp t (actual rows=10 loops=1)
(24 rows)

DROP TABLE compressed_join_temp;
-- test join with partially compressed chunks
CREATE TABLE partial_join(time timestamptz,device text);
SELECT table_name FROM create_hypertable('partial_join','time');
NOTICE:  adding not-null constraint to column "time"
  table_name  
 partial_join
(1 row)

ALTER TABLE partial_join set(timescaledb.compress,timescaledb.compress_segmentby='device');
INSERT INTO partial_join SELECT '2000-01-01','d1';
SELECT count(*) FROM (SELECT compress_chunk(show_chunks('partial_join'),true)) compress;
 count 
     1
(1 row)

-- make chunk partially compressed
INSERT INTO partial_join SELECT '2000-01-01','d1';
SELECT * FROM partial_join m1 INNER JOIN partial_join m2 ON m1.device = m2.device;
             time             | device |             time             | device 
------------------------------+--------+------------------------------+--------
 Sat Jan 01 00:00:00 2000 PST | d1     | Sat Jan 01 00:00:00 2000 PST | d1
 Sat Jan 01 00:00:00 2000 PST | d1     | Sat Jan 01 00:00:00 2000 PST | d1
 Sat Jan 01 00:00:00 2000 PST | d1     | Sat Jan 01 00:00:00 2000 PST | d1
 Sat Jan 01 00:00:00 2000 PST | d1     | Sat Jan 01 00:00:00 2000 PST | d1
(4 rows)

DROP TABLE partial_join;
-- This resulted in a recursion in the join planner code on PG16
SELECT * FROM metrics_tstz as m
INNER JOIN metrics_space as ms on (true)
INNER JOIN metrics_space_compressed as msc on (true)
WHERE CASE WHEN m.device_id is not NULL and ms.v2 is not NULL THEN NULL::int2 end = msc.device_id;
 time | device_id | v1 | v2 | time | device_id | v0 | v1 | v2 | v3 | time | device_id | v0 | v1 | v2 | v3 
------+-----------+----+----+------+-----------+----+----+----+----+------+-----------+----+----+----+----
(0 rows)


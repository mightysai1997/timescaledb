-- This file and its contents are licensed under the Apache License 2.0.
-- Please see the included NOTICE for copyright information and
-- LICENSE-APACHE for a copy of the license.
-- we run these with analyze to confirm that nodes that are not
-- needed to fulfill the limit are not executed
-- unfortunately this doesn't work on PostgreSQL 9.6 which lacks
-- the ability to turn off analyze timing summary so we run
-- them without ANALYZE on PostgreSQL 9.6, but since LATERAL plans
-- are different across versions we need version specific output
-- here anyway.
\set TEST_BASE_NAME plan_ordered_append
SELECT format('include/%s_load.sql', :'TEST_BASE_NAME') as "TEST_LOAD_NAME",
       format('include/%s_query.sql', :'TEST_BASE_NAME') as "TEST_QUERY_NAME",
       format('%s/results/%s_results_optimized.out', :'TEST_OUTPUT_DIR', :'TEST_BASE_NAME') as "TEST_RESULTS_OPTIMIZED",
       format('%s/results/%s_results_unoptimized.out', :'TEST_OUTPUT_DIR', :'TEST_BASE_NAME') as "TEST_RESULTS_UNOPTIMIZED"
\gset
SELECT format('\! diff %s %s', :'TEST_RESULTS_OPTIMIZED', :'TEST_RESULTS_UNOPTIMIZED') as "DIFF_CMD"
\gset
-- look at postgres version to decide whether we run with analyze or without
SELECT
  CASE WHEN current_setting('server_version_num')::int >= 100000
    THEN 'EXPLAIN (analyze, costs off, timing off, summary off)'
    ELSE 'EXPLAIN (costs off)'
  END AS "PREFIX"
\gset
\set PREFIX_NO_ANALYZE 'EXPLAIN (costs off)'
\ir :TEST_LOAD_NAME
-- This file and its contents are licensed under the Apache License 2.0.
-- Please see the included NOTICE for copyright information and
-- LICENSE-APACHE for a copy of the license.
-- create a now() function for repeatable testing that always returns
-- the same timestamp. It needs to be marked STABLE
CREATE OR REPLACE FUNCTION now_s()
RETURNS timestamptz LANGUAGE PLPGSQL STABLE AS
$BODY$
BEGIN
    RETURN '2000-01-08T0:00:00+0'::timestamptz;
END;
$BODY$;
CREATE TABLE devices(device_id INT PRIMARY KEY, name TEXT);
INSERT INTO devices VALUES
(1,'Device 1'),
(2,'Device 2'),
(3,'Device 3');
-- create a table where we create chunks in order
CREATE TABLE ordered_append(time timestamptz NOT NULL, device_id INT, value float);
SELECT create_hypertable('ordered_append','time');
      create_hypertable      
-----------------------------
 (1,public,ordered_append,t)
(1 row)

CREATE index on ordered_append(time DESC,device_id);
CREATE index on ordered_append(device_id,time DESC);
INSERT INTO ordered_append SELECT generate_series('2000-01-01'::timestamptz,'2000-01-18'::timestamptz,'1m'::interval), 1, 0.5;
INSERT INTO ordered_append SELECT generate_series('2000-01-01'::timestamptz,'2000-01-18'::timestamptz,'1m'::interval), 2, 1.5;
INSERT INTO ordered_append SELECT generate_series('2000-01-01'::timestamptz,'2000-01-18'::timestamptz,'1m'::interval), 3, 2.5;
-- create a second table where we create chunks in reverse order
CREATE TABLE ordered_append_reverse(time timestamptz NOT NULL, device_id INT, value float);
SELECT create_hypertable('ordered_append_reverse','time');
          create_hypertable          
-------------------------------------
 (2,public,ordered_append_reverse,t)
(1 row)

INSERT INTO ordered_append_reverse SELECT generate_series('2000-01-18'::timestamptz,'2000-01-01'::timestamptz,'-1m'::interval), 1, 0.5;
-- table where dimension column is last column
CREATE TABLE IF NOT EXISTS dimension_last(
    id INT8 NOT NULL,
    device_id INT NOT NULL,
    name TEXT NOT NULL,
    time timestamptz NOT NULL
);
SELECT create_hypertable('dimension_last', 'time', chunk_time_interval => interval '1day', if_not_exists => True);
      create_hypertable      
-----------------------------
 (3,public,dimension_last,t)
(1 row)

-- table with only dimension column
CREATE TABLE IF NOT EXISTS dimension_only(
    time timestamptz NOT NULL
);
SELECT create_hypertable('dimension_only', 'time', chunk_time_interval => interval '1day', if_not_exists => True);
      create_hypertable      
-----------------------------
 (4,public,dimension_only,t)
(1 row)

INSERT INTO dimension_last SELECT 1,1,'Device 1',generate_series('2000-01-01 0:00:00+0'::timestamptz,'2000-01-04 23:59:00+0'::timestamptz,'1m'::interval);
INSERT INTO dimension_only VALUES
('2000-01-01'),
('2000-01-03'),
('2000-01-05'),
('2000-01-07');
ANALYZE devices;
ANALYZE ordered_append;
ANALYZE ordered_append_reverse;
ANALYZE dimension_last;
ANALYZE dimension_only;
-- create hypertable with indexes not on all chunks
CREATE TABLE ht_missing_indexes(time timestamptz NOT NULL, device_id int, value float);
SELECT create_hypertable('ht_missing_indexes','time');
        create_hypertable        
---------------------------------
 (5,public,ht_missing_indexes,t)
(1 row)

INSERT INTO ht_missing_indexes SELECT generate_series('2000-01-01'::timestamptz,'2000-01-18'::timestamptz,'1m'::interval), 1, 0.5;
INSERT INTO ht_missing_indexes SELECT generate_series('2000-01-01'::timestamptz,'2000-01-18'::timestamptz,'1m'::interval), 2, 1.5;
INSERT INTO ht_missing_indexes SELECT generate_series('2000-01-01'::timestamptz,'2000-01-18'::timestamptz,'1m'::interval), 3, 2.5;
-- drop index from 2nd chunk of ht_missing_indexes
SELECT format('%I.%I',i.schemaname,i.indexname) AS "INDEX_NAME"
FROM _timescaledb_catalog.chunk c
INNER JOIN _timescaledb_catalog.hypertable ht ON c.hypertable_id = ht.id
INNER JOIN pg_indexes i ON i.schemaname = c.schema_name AND i.tablename=c.table_name
WHERE ht.table_name = 'ht_missing_indexes'
ORDER BY c.id LIMIT 1 OFFSET 1 \gset
DROP INDEX :INDEX_NAME;
ANALYZE ht_missing_indexes;
-- create hypertable with with dropped columns
CREATE TABLE ht_dropped_columns(c1 int, c2 int, c3 int, c4 int, c5 int, time timestamptz NOT NULL, device_id int, value float);
SELECT create_hypertable('ht_dropped_columns','time');
        create_hypertable        
---------------------------------
 (6,public,ht_dropped_columns,t)
(1 row)

ALTER TABLE ht_dropped_columns DROP COLUMN c1;
INSERT INTO ht_dropped_columns(time,device_id,value) SELECT generate_series('2000-01-01'::timestamptz,'2000-01-02'::timestamptz,'1m'::interval), 1, 0.5;
ALTER TABLE ht_dropped_columns DROP COLUMN c2;
INSERT INTO ht_dropped_columns(time,device_id,value) SELECT generate_series('2000-01-08'::timestamptz,'2000-01-09'::timestamptz,'1m'::interval), 1, 0.5;
ALTER TABLE ht_dropped_columns DROP COLUMN c3;
INSERT INTO ht_dropped_columns(time,device_id,value) SELECT generate_series('2000-01-15'::timestamptz,'2000-01-16'::timestamptz,'1m'::interval), 1, 0.5;
ALTER TABLE ht_dropped_columns DROP COLUMN c4;
INSERT INTO ht_dropped_columns(time,device_id,value) SELECT generate_series('2000-01-22'::timestamptz,'2000-01-23'::timestamptz,'1m'::interval), 1, 0.5;
ALTER TABLE ht_dropped_columns DROP COLUMN c5;
INSERT INTO ht_dropped_columns(time,device_id,value) SELECT generate_series('2000-01-29'::timestamptz,'2000-01-30'::timestamptz,'1m'::interval), 1, 0.5;
ANALYZE ht_dropped_columns;
CREATE TABLE space(time timestamptz NOT NULL, device_id int NOT NULL, value float);
SELECT create_hypertable('space','time','device_id',number_partitions:=4);
 create_hypertable  
--------------------
 (7,public,space,t)
(1 row)

INSERT INTO space SELECT generate_series('2000-01-10'::timestamptz,'2000-01-01'::timestamptz,'-1m'::interval), 1, 1.5;
INSERT INTO space SELECT generate_series('2000-01-10'::timestamptz,'2000-01-01'::timestamptz,'-1m'::interval), 2, 2.5;
INSERT INTO space SELECT generate_series('2000-01-10'::timestamptz,'2000-01-01'::timestamptz,'-1m'::interval), 3, 3.5;
INSERT INTO space SELECT generate_series('2000-01-10'::timestamptz,'2000-01-01'::timestamptz,'-1m'::interval), 4, 4.5;
INSERT INTO space SELECT generate_series('2000-01-10'::timestamptz,'2000-01-01'::timestamptz,'-1m'::interval), 5, 5.5;
INSERT INTO space SELECT generate_series('2000-01-10'::timestamptz,'2000-01-01'::timestamptz,'-1m'::interval), 6, 6.5;
ANALYZE space;
CREATE TABLE space2(time timestamptz NOT NULL, device_id int NOT NULL, tag_id int NOT NULL, value float);
SELECT create_hypertable('space2','time','device_id',number_partitions:=3);
  create_hypertable  
---------------------
 (8,public,space2,t)
(1 row)

SELECT add_dimension('space2','tag_id',number_partitions:=3);
        add_dimension        
-----------------------------
 (11,public,space2,tag_id,t)
(1 row)

INSERT INTO space2 SELECT generate_series('2000-01-10'::timestamptz,'2000-01-01'::timestamptz,'-1m'::interval), 1, 1, 1.5;
INSERT INTO space2 SELECT generate_series('2000-01-10'::timestamptz,'2000-01-01'::timestamptz,'-1m'::interval), 2, 1, 2.5;
INSERT INTO space2 SELECT generate_series('2000-01-10'::timestamptz,'2000-01-01'::timestamptz,'-1m'::interval), 3, 1, 3.5;
INSERT INTO space2 SELECT generate_series('2000-01-10'::timestamptz,'2000-01-01'::timestamptz,'-1m'::interval), 1, 2, 1.5;
INSERT INTO space2 SELECT generate_series('2000-01-10'::timestamptz,'2000-01-01'::timestamptz,'-1m'::interval), 2, 2, 2.5;
INSERT INTO space2 SELECT generate_series('2000-01-10'::timestamptz,'2000-01-01'::timestamptz,'-1m'::interval), 3, 2, 3.5;
INSERT INTO space2 SELECT generate_series('2000-01-10'::timestamptz,'2000-01-01'::timestamptz,'-1m'::interval), 1, 3, 1.5;
INSERT INTO space2 SELECT generate_series('2000-01-10'::timestamptz,'2000-01-01'::timestamptz,'-1m'::interval), 2, 3, 2.5;
INSERT INTO space2 SELECT generate_series('2000-01-10'::timestamptz,'2000-01-01'::timestamptz,'-1m'::interval), 3, 3, 3.5;
ANALYZE space2;
\ir :TEST_QUERY_NAME
-- This file and its contents are licensed under the Apache License 2.0.
-- Please see the included NOTICE for copyright information and
-- LICENSE-APACHE for a copy of the license.
-- print chunks ordered by time to ensure ordering we want
SELECT
  ht.table_name AS hypertable,
  c.table_name AS chunk,
  ds.range_start
FROM
  _timescaledb_catalog.chunk c
  INNER JOIN LATERAL(SELECT * FROM _timescaledb_catalog.chunk_constraint cc WHERE c.id = cc.chunk_id ORDER BY cc.dimension_slice_id LIMIT 1) cc ON true
  INNER JOIN _timescaledb_catalog.dimension_slice ds ON ds.id=cc.dimension_slice_id
  INNER JOIN _timescaledb_catalog.dimension d ON ds.dimension_id = d.id
  INNER JOIN _timescaledb_catalog.hypertable ht ON d.hypertable_id = ht.id
ORDER BY ht.table_name, range_start, chunk;
       hypertable       |       chunk       |     range_start      
------------------------+-------------------+----------------------
 dimension_last         | _hyper_3_7_chunk  |      946684800000000
 dimension_last         | _hyper_3_8_chunk  |      946771200000000
 dimension_last         | _hyper_3_9_chunk  |      946857600000000
 dimension_last         | _hyper_3_10_chunk |      946944000000000
 dimension_only         | _hyper_4_11_chunk |      946684800000000
 dimension_only         | _hyper_4_12_chunk |      946857600000000
 dimension_only         | _hyper_4_13_chunk |      947030400000000
 dimension_only         | _hyper_4_14_chunk |      947203200000000
 ht_dropped_columns     | _hyper_6_18_chunk |      946512000000000
 ht_dropped_columns     | _hyper_6_19_chunk |      947116800000000
 ht_dropped_columns     | _hyper_6_20_chunk |      947721600000000
 ht_dropped_columns     | _hyper_6_21_chunk |      948326400000000
 ht_dropped_columns     | _hyper_6_22_chunk |      948931200000000
 ht_missing_indexes     | _hyper_5_15_chunk |      946512000000000
 ht_missing_indexes     | _hyper_5_16_chunk |      947116800000000
 ht_missing_indexes     | _hyper_5_17_chunk |      947721600000000
 ordered_append         | _hyper_1_1_chunk  |      946512000000000
 ordered_append         | _hyper_1_2_chunk  |      947116800000000
 ordered_append         | _hyper_1_3_chunk  |      947721600000000
 ordered_append_reverse | _hyper_2_6_chunk  |      946512000000000
 ordered_append_reverse | _hyper_2_5_chunk  |      947116800000000
 ordered_append_reverse | _hyper_2_4_chunk  |      947721600000000
 space                  | _hyper_7_24_chunk | -9223372036854775808
 space                  | _hyper_7_26_chunk |      946512000000000
 space                  | _hyper_7_28_chunk |      946512000000000
 space                  | _hyper_7_30_chunk |      946512000000000
 space                  | _hyper_7_23_chunk |      947116800000000
 space                  | _hyper_7_25_chunk |      947116800000000
 space                  | _hyper_7_27_chunk |      947116800000000
 space                  | _hyper_7_29_chunk |      947116800000000
 space2                 | _hyper_8_32_chunk | -9223372036854775808
 space2                 | _hyper_8_34_chunk | -9223372036854775808
 space2                 | _hyper_8_36_chunk | -9223372036854775808
 space2                 | _hyper_8_38_chunk | -9223372036854775808
 space2                 | _hyper_8_44_chunk | -9223372036854775808
 space2                 | _hyper_8_40_chunk |      946512000000000
 space2                 | _hyper_8_42_chunk |      946512000000000
 space2                 | _hyper_8_46_chunk |      946512000000000
 space2                 | _hyper_8_48_chunk |      946512000000000
 space2                 | _hyper_8_31_chunk |      947116800000000
 space2                 | _hyper_8_33_chunk |      947116800000000
 space2                 | _hyper_8_35_chunk |      947116800000000
 space2                 | _hyper_8_37_chunk |      947116800000000
 space2                 | _hyper_8_39_chunk |      947116800000000
 space2                 | _hyper_8_41_chunk |      947116800000000
 space2                 | _hyper_8_43_chunk |      947116800000000
 space2                 | _hyper_8_45_chunk |      947116800000000
 space2                 | _hyper_8_47_chunk |      947116800000000
(48 rows)

-- test ASC for ordered chunks
:PREFIX SELECT
  time, device_id, value
FROM ordered_append
ORDER BY time ASC LIMIT 1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append
         ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=1 loops=1)
         ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
         ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (never executed)
(6 rows)

-- test DESC for ordered chunks
:PREFIX SELECT
  time, device_id, value
FROM ordered_append
ORDER BY time DESC LIMIT 1;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append
         ->  Index Scan using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
         ->  Index Scan using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
         ->  Index Scan using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (never executed)
(6 rows)

-- test ASC for reverse ordered chunks
:PREFIX SELECT
  time, device_id, value
FROM ordered_append_reverse
ORDER BY time ASC LIMIT 1;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append_reverse
         ->  Index Scan Backward using _hyper_2_6_chunk_ordered_append_reverse_time_idx on _hyper_2_6_chunk (actual rows=1 loops=1)
         ->  Index Scan Backward using _hyper_2_5_chunk_ordered_append_reverse_time_idx on _hyper_2_5_chunk (never executed)
         ->  Index Scan Backward using _hyper_2_4_chunk_ordered_append_reverse_time_idx on _hyper_2_4_chunk (never executed)
(6 rows)

-- test DESC for reverse ordered chunks
:PREFIX SELECT
  time, device_id, value
FROM ordered_append_reverse
ORDER BY time DESC LIMIT 1;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append_reverse
         ->  Index Scan using _hyper_2_4_chunk_ordered_append_reverse_time_idx on _hyper_2_4_chunk (actual rows=1 loops=1)
         ->  Index Scan using _hyper_2_5_chunk_ordered_append_reverse_time_idx on _hyper_2_5_chunk (never executed)
         ->  Index Scan using _hyper_2_6_chunk_ordered_append_reverse_time_idx on _hyper_2_6_chunk (never executed)
(6 rows)

-- test query with ORDER BY column not in targetlist
:PREFIX SELECT
  device_id, value
FROM ordered_append
ORDER BY time ASC LIMIT 1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append
         ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=1 loops=1)
         ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
         ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (never executed)
(6 rows)

-- ORDER BY may include other columns after time column
:PREFIX SELECT
  time, device_id, value
FROM ordered_append
ORDER BY time DESC, device_id LIMIT 1;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append
         ->  Index Scan using _hyper_1_3_chunk_ordered_append_time_device_id_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
         ->  Index Scan using _hyper_1_2_chunk_ordered_append_time_device_id_idx on _hyper_1_2_chunk (never executed)
         ->  Index Scan using _hyper_1_1_chunk_ordered_append_time_device_id_idx on _hyper_1_1_chunk (never executed)
(6 rows)

-- test RECORD in targetlist
:PREFIX SELECT
  (time, device_id, value)
FROM ordered_append
ORDER BY time DESC, device_id LIMIT 1;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append
         ->  Index Scan using _hyper_1_3_chunk_ordered_append_time_device_id_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
         ->  Index Scan using _hyper_1_2_chunk_ordered_append_time_device_id_idx on _hyper_1_2_chunk (never executed)
         ->  Index Scan using _hyper_1_1_chunk_ordered_append_time_device_id_idx on _hyper_1_1_chunk (never executed)
(6 rows)

-- queries with ORDER BY non-time column shouldn't use ordered append
:PREFIX SELECT
  time, device_id, value
FROM ordered_append
ORDER BY device_id LIMIT 1;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Merge Append (actual rows=1 loops=1)
         Sort Key: _hyper_1_1_chunk.device_id
         ->  Index Scan using _hyper_1_1_chunk_ordered_append_device_id_time_idx on _hyper_1_1_chunk (actual rows=1 loops=1)
         ->  Index Scan using _hyper_1_2_chunk_ordered_append_device_id_time_idx on _hyper_1_2_chunk (actual rows=1 loops=1)
         ->  Index Scan using _hyper_1_3_chunk_ordered_append_device_id_time_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
(6 rows)

-- time column must be primary sort order
:PREFIX SELECT
  time, device_id, value
FROM ordered_append
ORDER BY device_id, time LIMIT 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Sort (actual rows=1 loops=1)
         Sort Key: _hyper_1_1_chunk.device_id, _hyper_1_1_chunk."time"
         Sort Method: top-N heapsort  Memory: 25kB
         ->  Append (actual rows=73443 loops=1)
               ->  Seq Scan on _hyper_1_1_chunk (actual rows=20160 loops=1)
               ->  Seq Scan on _hyper_1_2_chunk (actual rows=30240 loops=1)
               ->  Seq Scan on _hyper_1_3_chunk (actual rows=23043 loops=1)
(8 rows)

-- queries without LIMIT shouldnt use ordered append
:PREFIX SELECT
  time, device_id, value
FROM ordered_append
ORDER BY time ASC;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ChunkAppend) (actual rows=73443 loops=1)
   Hypertable: ordered_append
   ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=20160 loops=1)
   ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (actual rows=30240 loops=1)
   ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=23043 loops=1)
(5 rows)

-- queries without ORDER BY shouldnt use ordered append (still uses append though)
:PREFIX SELECT
  time, device_id, value
FROM ordered_append
LIMIT 1;
                            QUERY PLAN                            
------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Append (actual rows=1 loops=1)
         ->  Seq Scan on _hyper_1_1_chunk (actual rows=1 loops=1)
         ->  Seq Scan on _hyper_1_2_chunk (never executed)
         ->  Seq Scan on _hyper_1_3_chunk (never executed)
(5 rows)

-- test interaction with constraint exclusion
:PREFIX SELECT
  time, device_id, value
FROM ordered_append
WHERE time > '2000-01-07'
ORDER BY time ASC LIMIT 1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append
         ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (actual rows=1 loops=1)
               Index Cond: ("time" > 'Fri Jan 07 00:00:00 2000 PST'::timestamp with time zone)
         ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (never executed)
               Index Cond: ("time" > 'Fri Jan 07 00:00:00 2000 PST'::timestamp with time zone)
(7 rows)

:PREFIX SELECT
  time, device_id, value
FROM ordered_append
WHERE time > '2000-01-07'
ORDER BY time DESC LIMIT 1;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append
         ->  Index Scan using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
               Index Cond: ("time" > 'Fri Jan 07 00:00:00 2000 PST'::timestamp with time zone)
         ->  Index Scan using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
               Index Cond: ("time" > 'Fri Jan 07 00:00:00 2000 PST'::timestamp with time zone)
(7 rows)

-- test interaction with constraint aware append
:PREFIX SELECT
  time, device_id, value
FROM ordered_append
WHERE time > now_s()
ORDER BY time ASC LIMIT 1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append
         Chunks excluded during startup: 1
         ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (actual rows=1 loops=1)
               Index Cond: ("time" > now_s())
         ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (never executed)
               Index Cond: ("time" > now_s())
(8 rows)

:PREFIX SELECT
  time, device_id, value
FROM ordered_append
WHERE time < now_s()
ORDER BY time ASC LIMIT 1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append
         Chunks excluded during startup: 1
         ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=1 loops=1)
               Index Cond: ("time" < now_s())
         ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
               Index Cond: ("time" < now_s())
(8 rows)

-- test constraint exclusion
:PREFIX SELECT
  time, device_id, value
FROM ordered_append
WHERE time > now_s() AND time < '2000-01-10'
ORDER BY time ASC LIMIT 1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append
         Chunks excluded during startup: 1
         ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (actual rows=1 loops=1)
               Index Cond: (("time" > now_s()) AND ("time" < 'Mon Jan 10 00:00:00 2000 PST'::timestamp with time zone))
(6 rows)

:PREFIX SELECT
  time, device_id, value
FROM ordered_append
WHERE time < now_s() AND time > '2000-01-07'
ORDER BY time ASC LIMIT 1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append
         Chunks excluded during startup: 1
         ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (actual rows=1 loops=1)
               Index Cond: (("time" < now_s()) AND ("time" > 'Fri Jan 07 00:00:00 2000 PST'::timestamp with time zone))
(6 rows)

-- min/max queries
:PREFIX SELECT max(time) FROM ordered_append;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=1 loops=1)
   InitPlan 1 (returns $0)
     ->  Limit (actual rows=1 loops=1)
           ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
                 Hypertable: ordered_append
                 ->  Index Only Scan using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
                       Index Cond: ("time" IS NOT NULL)
                       Heap Fetches: 1
                 ->  Index Only Scan using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
                       Index Cond: ("time" IS NOT NULL)
                       Heap Fetches: 0
                 ->  Index Only Scan using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (never executed)
                       Index Cond: ("time" IS NOT NULL)
                       Heap Fetches: 0
(14 rows)

:PREFIX SELECT min(time) FROM ordered_append;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=1 loops=1)
   InitPlan 1 (returns $0)
     ->  Limit (actual rows=1 loops=1)
           ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
                 Hypertable: ordered_append
                 ->  Index Only Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=1 loops=1)
                       Index Cond: ("time" IS NOT NULL)
                       Heap Fetches: 1
                 ->  Index Only Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
                       Index Cond: ("time" IS NOT NULL)
                       Heap Fetches: 0
                 ->  Index Only Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (never executed)
                       Index Cond: ("time" IS NOT NULL)
                       Heap Fetches: 0
(14 rows)

-- test first/last (doesn't use ordered append yet)
:PREFIX SELECT first(time, time) FROM ordered_append;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=1 loops=1)
   InitPlan 1 (returns $0)
     ->  Limit (actual rows=1 loops=1)
           ->  Result (actual rows=1 loops=1)
                 ->  Merge Append (actual rows=1 loops=1)
                       Sort Key: _hyper_1_1_chunk."time"
                       ->  Index Only Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=1 loops=1)
                             Index Cond: ("time" IS NOT NULL)
                             Heap Fetches: 1
                       ->  Index Only Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (actual rows=1 loops=1)
                             Index Cond: ("time" IS NOT NULL)
                             Heap Fetches: 1
                       ->  Index Only Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
                             Index Cond: ("time" IS NOT NULL)
                             Heap Fetches: 1
(15 rows)

:PREFIX SELECT last(time, time) FROM ordered_append;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=1 loops=1)
   InitPlan 1 (returns $0)
     ->  Limit (actual rows=1 loops=1)
           ->  Result (actual rows=1 loops=1)
                 ->  Merge Append (actual rows=1 loops=1)
                       Sort Key: _hyper_1_1_chunk."time" DESC
                       ->  Index Only Scan using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=1 loops=1)
                             Index Cond: ("time" IS NOT NULL)
                             Heap Fetches: 1
                       ->  Index Only Scan using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (actual rows=1 loops=1)
                             Index Cond: ("time" IS NOT NULL)
                             Heap Fetches: 1
                       ->  Index Only Scan using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
                             Index Cond: ("time" IS NOT NULL)
                             Heap Fetches: 1
(15 rows)

-- test query with time_bucket
:PREFIX SELECT
  time_bucket('1d',time), device_id, value
FROM ordered_append
ORDER BY time ASC LIMIT 1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append
         ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=1 loops=1)
         ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
         ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (never executed)
(6 rows)

-- test query with order by time_bucket (should not use ordered append)
:PREFIX SELECT
  time_bucket('1d',time), device_id, value
FROM ordered_append
ORDER BY 1 LIMIT 1;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Result (actual rows=1 loops=1)
         ->  Merge Append (actual rows=1 loops=1)
               Sort Key: (time_bucket('@ 1 day'::interval, _hyper_1_1_chunk."time"))
               ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=1 loops=1)
               ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (actual rows=1 loops=1)
               ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
(7 rows)

-- test query with order by time_bucket (should not use ordered append)
:PREFIX SELECT
  time_bucket('1d',time), device_id, value
FROM ordered_append
ORDER BY time_bucket('1d',time) LIMIT 1;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Result (actual rows=1 loops=1)
         ->  Merge Append (actual rows=1 loops=1)
               Sort Key: (time_bucket('@ 1 day'::interval, _hyper_1_1_chunk."time"))
               ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=1 loops=1)
               ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (actual rows=1 loops=1)
               ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
(7 rows)

-- test query with now() should result in ordered append with constraint aware append
:PREFIX SELECT * FROM ordered_append WHERE time < now() + '1 month'
ORDER BY time DESC limit 1;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append
         Chunks excluded during startup: 0
         ->  Index Scan using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
               Index Cond: ("time" < (now() + '@ 1 mon'::interval))
         ->  Index Scan using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
               Index Cond: ("time" < (now() + '@ 1 mon'::interval))
         ->  Index Scan using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (never executed)
               Index Cond: ("time" < (now() + '@ 1 mon'::interval))
(10 rows)

-- test CTE
:PREFIX WITH i AS (SELECT * FROM ordered_append WHERE time < now() ORDER BY time DESC limit 100)
SELECT * FROM i;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 CTE Scan on i (actual rows=100 loops=1)
   CTE i
     ->  Limit (actual rows=100 loops=1)
           ->  Custom Scan (ChunkAppend) (actual rows=100 loops=1)
                 Hypertable: ordered_append
                 Chunks excluded during startup: 0
                 ->  Index Scan using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=100 loops=1)
                       Index Cond: ("time" < now())
                 ->  Index Scan using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
                       Index Cond: ("time" < now())
                 ->  Index Scan using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (never executed)
                       Index Cond: ("time" < now())
(12 rows)

-- test LATERAL with ordered append in the outer query
:PREFIX SELECT * FROM ordered_append, LATERAL(SELECT * FROM (VALUES (1),(2)) v) l ORDER BY time DESC limit 2;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=2 loops=1)
   ->  Nested Loop (actual rows=2 loops=1)
         ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
               Hypertable: ordered_append
               ->  Index Scan using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
               ->  Index Scan using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
               ->  Index Scan using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (never executed)
         ->  Materialize (actual rows=2 loops=1)
               ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
(9 rows)

-- test LATERAL with ordered append in the lateral query
:PREFIX SELECT * FROM (VALUES (1),(2)) v, LATERAL(SELECT * FROM ordered_append ORDER BY time DESC limit 2) l;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Nested Loop (actual rows=4 loops=1)
   ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
   ->  Materialize (actual rows=2 loops=2)
         ->  Limit (actual rows=2 loops=1)
               ->  Custom Scan (ChunkAppend) (actual rows=2 loops=1)
                     Hypertable: ordered_append
                     ->  Index Scan using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=2 loops=1)
                     ->  Index Scan using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
                     ->  Index Scan using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (never executed)
(9 rows)

-- test plan with best index is chosen
-- this should use device_id, time index
:PREFIX SELECT * FROM ordered_append WHERE device_id = 1 ORDER BY time DESC LIMIT 1;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append
         ->  Index Scan using _hyper_1_3_chunk_ordered_append_device_id_time_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
               Index Cond: (device_id = 1)
         ->  Index Scan using _hyper_1_2_chunk_ordered_append_device_id_time_idx on _hyper_1_2_chunk (never executed)
               Index Cond: (device_id = 1)
         ->  Index Scan using _hyper_1_1_chunk_ordered_append_device_id_time_idx on _hyper_1_1_chunk (never executed)
               Index Cond: (device_id = 1)
(9 rows)

-- test plan with best index is chosen
-- this should use time index
:PREFIX SELECT * FROM ordered_append ORDER BY time DESC LIMIT 1;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ordered_append
         ->  Index Scan using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
         ->  Index Scan using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
         ->  Index Scan using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (never executed)
(6 rows)

-- test with table with only dimension column
:PREFIX SELECT * FROM dimension_only ORDER BY time DESC LIMIT 1;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: dimension_only
         ->  Index Only Scan using _hyper_4_14_chunk_dimension_only_time_idx on _hyper_4_14_chunk (actual rows=1 loops=1)
               Heap Fetches: 1
         ->  Index Only Scan using _hyper_4_13_chunk_dimension_only_time_idx on _hyper_4_13_chunk (never executed)
               Heap Fetches: 0
         ->  Index Only Scan using _hyper_4_12_chunk_dimension_only_time_idx on _hyper_4_12_chunk (never executed)
               Heap Fetches: 0
         ->  Index Only Scan using _hyper_4_11_chunk_dimension_only_time_idx on _hyper_4_11_chunk (never executed)
               Heap Fetches: 0
(11 rows)

-- test LEFT JOIN against hypertable
:PREFIX_NO_ANALYZE SELECT *
FROM dimension_last
LEFT JOIN dimension_only USING (time)
ORDER BY dimension_last.time DESC
LIMIT 2;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Limit
   ->  Nested Loop Left Join
         Join Filter: (dimension_last."time" = _hyper_4_14_chunk."time")
         ->  Custom Scan (ChunkAppend)
               Hypertable: dimension_last
               ->  Index Scan using _hyper_3_10_chunk_dimension_last_time_idx on _hyper_3_10_chunk
               ->  Index Scan using _hyper_3_9_chunk_dimension_last_time_idx on _hyper_3_9_chunk
               ->  Index Scan using _hyper_3_8_chunk_dimension_last_time_idx on _hyper_3_8_chunk
               ->  Index Scan using _hyper_3_7_chunk_dimension_last_time_idx on _hyper_3_7_chunk
         ->  Materialize
               ->  Append
                     ->  Seq Scan on _hyper_4_14_chunk
                     ->  Seq Scan on _hyper_4_13_chunk
                     ->  Seq Scan on _hyper_4_12_chunk
                     ->  Seq Scan on _hyper_4_11_chunk
(15 rows)

-- test INNER JOIN against non-hypertable
:PREFIX_NO_ANALYZE SELECT *
FROM dimension_last
INNER JOIN dimension_only USING (time)
ORDER BY dimension_last.time DESC
LIMIT 2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Limit
   ->  Nested Loop
         ->  Custom Scan (ChunkAppend)
               Hypertable: dimension_only
               ->  Index Only Scan using _hyper_4_14_chunk_dimension_only_time_idx on _hyper_4_14_chunk
               ->  Index Only Scan using _hyper_4_13_chunk_dimension_only_time_idx on _hyper_4_13_chunk
               ->  Index Only Scan using _hyper_4_12_chunk_dimension_only_time_idx on _hyper_4_12_chunk
               ->  Index Only Scan using _hyper_4_11_chunk_dimension_only_time_idx on _hyper_4_11_chunk
         ->  Append
               ->  Index Scan using _hyper_3_10_chunk_dimension_last_time_idx on _hyper_3_10_chunk
                     Index Cond: ("time" = dimension_only."time")
               ->  Index Scan using _hyper_3_9_chunk_dimension_last_time_idx on _hyper_3_9_chunk
                     Index Cond: ("time" = dimension_only."time")
               ->  Index Scan using _hyper_3_8_chunk_dimension_last_time_idx on _hyper_3_8_chunk
                     Index Cond: ("time" = dimension_only."time")
               ->  Index Scan using _hyper_3_7_chunk_dimension_last_time_idx on _hyper_3_7_chunk
                     Index Cond: ("time" = dimension_only."time")
(17 rows)

-- test join against non-hypertable
:PREFIX SELECT *
FROM dimension_last
INNER JOIN devices USING(device_id)
ORDER BY dimension_last.time DESC
LIMIT 2;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=2 loops=1)
   ->  Nested Loop (actual rows=2 loops=1)
         Join Filter: (dimension_last.device_id = devices.device_id)
         ->  Custom Scan (ChunkAppend) (actual rows=2 loops=1)
               Hypertable: dimension_last
               ->  Index Scan using _hyper_3_10_chunk_dimension_last_time_idx on _hyper_3_10_chunk (actual rows=2 loops=1)
               ->  Index Scan using _hyper_3_9_chunk_dimension_last_time_idx on _hyper_3_9_chunk (never executed)
               ->  Index Scan using _hyper_3_8_chunk_dimension_last_time_idx on _hyper_3_8_chunk (never executed)
               ->  Index Scan using _hyper_3_7_chunk_dimension_last_time_idx on _hyper_3_7_chunk (never executed)
         ->  Materialize (actual rows=1 loops=2)
               ->  Seq Scan on devices (actual rows=1 loops=1)
(11 rows)

-- test hypertable with index missing on one chunk
:PREFIX SELECT
  time, device_id, value
FROM ht_missing_indexes
ORDER BY time ASC LIMIT 1;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ht_missing_indexes
         ->  Index Scan Backward using _hyper_5_15_chunk_ht_missing_indexes_time_idx on _hyper_5_15_chunk (actual rows=1 loops=1)
         ->  Sort (never executed)
               Sort Key: _hyper_5_16_chunk."time"
               ->  Seq Scan on _hyper_5_16_chunk (never executed)
         ->  Index Scan Backward using _hyper_5_17_chunk_ht_missing_indexes_time_idx on _hyper_5_17_chunk (never executed)
(8 rows)

-- test hypertable with index missing on one chunk
-- and no data
:PREFIX SELECT
  time, device_id, value
FROM ht_missing_indexes
WHERE device_id = 2
ORDER BY time DESC LIMIT 1;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ht_missing_indexes
         ->  Index Scan using _hyper_5_17_chunk_ht_missing_indexes_time_idx on _hyper_5_17_chunk (actual rows=1 loops=1)
               Filter: (device_id = 2)
               Rows Removed by Filter: 1
         ->  Sort (never executed)
               Sort Key: _hyper_5_16_chunk."time" DESC
               ->  Seq Scan on _hyper_5_16_chunk (never executed)
                     Filter: (device_id = 2)
         ->  Index Scan using _hyper_5_15_chunk_ht_missing_indexes_time_idx on _hyper_5_15_chunk (never executed)
               Filter: (device_id = 2)
(12 rows)

-- test hypertable with index missing on one chunk
-- and no data
:PREFIX SELECT
  time, device_id, value
FROM ht_missing_indexes
WHERE time > '2000-01-07'
ORDER BY time LIMIT 10;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=10 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=10 loops=1)
         Hypertable: ht_missing_indexes
         ->  Sort (actual rows=10 loops=1)
               Sort Key: _hyper_5_16_chunk."time"
               Sort Method: top-N heapsort  Memory: 25kB
               ->  Seq Scan on _hyper_5_16_chunk (actual rows=24477 loops=1)
                     Filter: ("time" > 'Fri Jan 07 00:00:00 2000 PST'::timestamp with time zone)
                     Rows Removed by Filter: 5763
         ->  Index Scan Backward using _hyper_5_17_chunk_ht_missing_indexes_time_idx on _hyper_5_17_chunk (never executed)
               Index Cond: ("time" > 'Fri Jan 07 00:00:00 2000 PST'::timestamp with time zone)
(11 rows)

-- test hypertable with dropped columns
:PREFIX SELECT
  time, device_id, value
FROM ht_dropped_columns
ORDER BY time ASC LIMIT 1;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
         Hypertable: ht_dropped_columns
         ->  Index Scan Backward using _hyper_6_18_chunk_ht_dropped_columns_time_idx on _hyper_6_18_chunk (actual rows=1 loops=1)
         ->  Index Scan Backward using _hyper_6_19_chunk_ht_dropped_columns_time_idx on _hyper_6_19_chunk (never executed)
         ->  Index Scan Backward using _hyper_6_20_chunk_ht_dropped_columns_time_idx on _hyper_6_20_chunk (never executed)
         ->  Index Scan Backward using _hyper_6_21_chunk_ht_dropped_columns_time_idx on _hyper_6_21_chunk (never executed)
         ->  Index Scan Backward using _hyper_6_22_chunk_ht_dropped_columns_time_idx on _hyper_6_22_chunk (never executed)
(8 rows)

-- test hypertable with dropped columns
:PREFIX SELECT
  time, device_id, value
FROM ht_dropped_columns
WHERE device_id = 1
ORDER BY time DESC;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Custom Scan (ChunkAppend) (actual rows=7205 loops=1)
   Hypertable: ht_dropped_columns
   ->  Index Scan using _hyper_6_22_chunk_ht_dropped_columns_time_idx on _hyper_6_22_chunk (actual rows=1441 loops=1)
         Filter: (device_id = 1)
   ->  Index Scan using _hyper_6_21_chunk_ht_dropped_columns_time_idx on _hyper_6_21_chunk (actual rows=1441 loops=1)
         Filter: (device_id = 1)
   ->  Index Scan using _hyper_6_20_chunk_ht_dropped_columns_time_idx on _hyper_6_20_chunk (actual rows=1441 loops=1)
         Filter: (device_id = 1)
   ->  Index Scan using _hyper_6_19_chunk_ht_dropped_columns_time_idx on _hyper_6_19_chunk (actual rows=1441 loops=1)
         Filter: (device_id = 1)
   ->  Index Scan using _hyper_6_18_chunk_ht_dropped_columns_time_idx on _hyper_6_18_chunk (actual rows=1441 loops=1)
         Filter: (device_id = 1)
(12 rows)

-- test hypertable with space partitioning
:PREFIX SELECT
  time, device_id, value
FROM space
ORDER BY time;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ChunkAppend) (actual rows=77766 loops=1)
   Hypertable: space
   ->  Merge Append (actual rows=40320 loops=1)
         Sort Key: _hyper_7_24_chunk."time"
         ->  Index Scan Backward using _hyper_7_24_chunk_space_time_idx on _hyper_7_24_chunk (actual rows=6720 loops=1)
         ->  Index Scan Backward using _hyper_7_26_chunk_space_time_idx on _hyper_7_26_chunk (actual rows=13440 loops=1)
         ->  Index Scan Backward using _hyper_7_28_chunk_space_time_idx on _hyper_7_28_chunk (actual rows=6720 loops=1)
         ->  Index Scan Backward using _hyper_7_30_chunk_space_time_idx on _hyper_7_30_chunk (actual rows=13440 loops=1)
   ->  Merge Append (actual rows=37446 loops=1)
         Sort Key: _hyper_7_23_chunk."time"
         ->  Index Scan Backward using _hyper_7_23_chunk_space_time_idx on _hyper_7_23_chunk (actual rows=6241 loops=1)
         ->  Index Scan Backward using _hyper_7_25_chunk_space_time_idx on _hyper_7_25_chunk (actual rows=12482 loops=1)
         ->  Index Scan Backward using _hyper_7_27_chunk_space_time_idx on _hyper_7_27_chunk (actual rows=6241 loops=1)
         ->  Index Scan Backward using _hyper_7_29_chunk_space_time_idx on _hyper_7_29_chunk (actual rows=12482 loops=1)
(14 rows)

-- test hypertable with space partitioning and reverse order
:PREFIX SELECT
  time, device_id, value
FROM space
ORDER BY time DESC;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Custom Scan (ChunkAppend) (actual rows=77766 loops=1)
   Hypertable: space
   ->  Merge Append (actual rows=37446 loops=1)
         Sort Key: _hyper_7_23_chunk."time" DESC
         ->  Index Scan using _hyper_7_23_chunk_space_time_idx on _hyper_7_23_chunk (actual rows=6241 loops=1)
         ->  Index Scan using _hyper_7_25_chunk_space_time_idx on _hyper_7_25_chunk (actual rows=12482 loops=1)
         ->  Index Scan using _hyper_7_27_chunk_space_time_idx on _hyper_7_27_chunk (actual rows=6241 loops=1)
         ->  Index Scan using _hyper_7_29_chunk_space_time_idx on _hyper_7_29_chunk (actual rows=12482 loops=1)
   ->  Merge Append (actual rows=40320 loops=1)
         Sort Key: _hyper_7_24_chunk."time" DESC
         ->  Index Scan using _hyper_7_24_chunk_space_time_idx on _hyper_7_24_chunk (actual rows=6720 loops=1)
         ->  Index Scan using _hyper_7_26_chunk_space_time_idx on _hyper_7_26_chunk (actual rows=13440 loops=1)
         ->  Index Scan using _hyper_7_28_chunk_space_time_idx on _hyper_7_28_chunk (actual rows=6720 loops=1)
         ->  Index Scan using _hyper_7_30_chunk_space_time_idx on _hyper_7_30_chunk (actual rows=13440 loops=1)
(14 rows)

-- test hypertable with space partitioning ORDER BY multiple columns
-- does not use ordered append
:PREFIX SELECT
  time, device_id, value
FROM space
ORDER BY time, device_id LIMIT 1;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Sort (actual rows=1 loops=1)
         Sort Key: _hyper_7_24_chunk."time", _hyper_7_24_chunk.device_id
         Sort Method: top-N heapsort  Memory: 25kB
         ->  Append (actual rows=77766 loops=1)
               ->  Seq Scan on _hyper_7_24_chunk (actual rows=6720 loops=1)
               ->  Seq Scan on _hyper_7_26_chunk (actual rows=13440 loops=1)
               ->  Seq Scan on _hyper_7_28_chunk (actual rows=6720 loops=1)
               ->  Seq Scan on _hyper_7_30_chunk (actual rows=13440 loops=1)
               ->  Seq Scan on _hyper_7_23_chunk (actual rows=6241 loops=1)
               ->  Seq Scan on _hyper_7_25_chunk (actual rows=12482 loops=1)
               ->  Seq Scan on _hyper_7_27_chunk (actual rows=6241 loops=1)
               ->  Seq Scan on _hyper_7_29_chunk (actual rows=12482 loops=1)
(13 rows)

-- test hypertable with space partitioning ORDER BY non-time column
-- does not use ordered append
:PREFIX SELECT
  time, device_id, value
FROM space
ORDER BY device_id, time LIMIT 1;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Sort (actual rows=1 loops=1)
         Sort Key: _hyper_7_23_chunk.device_id, _hyper_7_23_chunk."time"
         Sort Method: top-N heapsort  Memory: 25kB
         ->  Append (actual rows=77766 loops=1)
               ->  Seq Scan on _hyper_7_23_chunk (actual rows=6241 loops=1)
               ->  Seq Scan on _hyper_7_24_chunk (actual rows=6720 loops=1)
               ->  Seq Scan on _hyper_7_25_chunk (actual rows=12482 loops=1)
               ->  Seq Scan on _hyper_7_26_chunk (actual rows=13440 loops=1)
               ->  Seq Scan on _hyper_7_27_chunk (actual rows=6241 loops=1)
               ->  Seq Scan on _hyper_7_28_chunk (actual rows=6720 loops=1)
               ->  Seq Scan on _hyper_7_29_chunk (actual rows=12482 loops=1)
               ->  Seq Scan on _hyper_7_30_chunk (actual rows=13440 loops=1)
(13 rows)

-- test hypertable with 2 space dimensions
-- does not use ordered append
:PREFIX SELECT
  time, device_id, value
FROM space2
ORDER BY time DESC;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Merge Append (actual rows=116649 loops=1)
   Sort Key: _hyper_8_31_chunk."time" DESC
   ->  Index Scan using _hyper_8_31_chunk_space2_time_idx on _hyper_8_31_chunk (actual rows=6241 loops=1)
   ->  Index Scan using _hyper_8_32_chunk_space2_time_idx on _hyper_8_32_chunk (actual rows=6720 loops=1)
   ->  Index Scan using _hyper_8_33_chunk_space2_time_idx on _hyper_8_33_chunk (actual rows=6241 loops=1)
   ->  Index Scan using _hyper_8_34_chunk_space2_time_idx on _hyper_8_34_chunk (actual rows=6720 loops=1)
   ->  Index Scan using _hyper_8_35_chunk_space2_time_idx on _hyper_8_35_chunk (actual rows=6241 loops=1)
   ->  Index Scan using _hyper_8_36_chunk_space2_time_idx on _hyper_8_36_chunk (actual rows=6720 loops=1)
   ->  Index Scan using _hyper_8_37_chunk_space2_time_idx on _hyper_8_37_chunk (actual rows=6241 loops=1)
   ->  Index Scan using _hyper_8_38_chunk_space2_time_idx on _hyper_8_38_chunk (actual rows=6720 loops=1)
   ->  Index Scan using _hyper_8_39_chunk_space2_time_idx on _hyper_8_39_chunk (actual rows=6241 loops=1)
   ->  Index Scan using _hyper_8_40_chunk_space2_time_idx on _hyper_8_40_chunk (actual rows=6720 loops=1)
   ->  Index Scan using _hyper_8_41_chunk_space2_time_idx on _hyper_8_41_chunk (actual rows=6241 loops=1)
   ->  Index Scan using _hyper_8_42_chunk_space2_time_idx on _hyper_8_42_chunk (actual rows=6720 loops=1)
   ->  Index Scan using _hyper_8_43_chunk_space2_time_idx on _hyper_8_43_chunk (actual rows=6241 loops=1)
   ->  Index Scan using _hyper_8_44_chunk_space2_time_idx on _hyper_8_44_chunk (actual rows=6720 loops=1)
   ->  Index Scan using _hyper_8_45_chunk_space2_time_idx on _hyper_8_45_chunk (actual rows=6241 loops=1)
   ->  Index Scan using _hyper_8_46_chunk_space2_time_idx on _hyper_8_46_chunk (actual rows=6720 loops=1)
   ->  Index Scan using _hyper_8_47_chunk_space2_time_idx on _hyper_8_47_chunk (actual rows=6241 loops=1)
   ->  Index Scan using _hyper_8_48_chunk_space2_time_idx on _hyper_8_48_chunk (actual rows=6720 loops=1)
(20 rows)

-- test LATERAL with correlated query
-- only last chunk should be executed
:PREFIX SELECT *
FROM generate_series('2000-01-01'::timestamptz,'2000-01-03','1d') AS g(time)
LEFT OUTER JOIN LATERAL(
  SELECT * FROM ordered_append o
    WHERE o.time >= g.time AND o.time < g.time + '1d'::interval ORDER BY time DESC LIMIT 1
) l ON true;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join (actual rows=3 loops=1)
   ->  Function Scan on generate_series g (actual rows=3 loops=1)
   ->  Limit (actual rows=1 loops=3)
         ->  Custom Scan (ChunkAppend) (actual rows=1 loops=3)
               Hypertable: ordered_append
               Chunks excluded during startup: 0
               Chunks excluded during runtime: 2
               ->  Index Scan using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o_1 (never executed)
                     Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)))
               ->  Index Scan using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o_2 (never executed)
                     Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)))
               ->  Index Scan using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o_3 (actual rows=1 loops=3)
                     Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)))
(13 rows)

-- test LATERAL with correlated query
-- only 2nd chunk should be executed
:PREFIX SELECT *
FROM generate_series('2000-01-10'::timestamptz,'2000-01-11','1d') AS g(time)
LEFT OUTER JOIN LATERAL(
  SELECT * FROM ordered_append o
    WHERE o.time >= g.time AND o.time < g.time + '1d'::interval ORDER BY time LIMIT 1
) l ON true;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join (actual rows=2 loops=1)
   ->  Function Scan on generate_series g (actual rows=2 loops=1)
   ->  Limit (actual rows=1 loops=2)
         ->  Custom Scan (ChunkAppend) (actual rows=1 loops=2)
               Hypertable: ordered_append
               Chunks excluded during startup: 0
               Chunks excluded during runtime: 2
               ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o_1 (never executed)
                     Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)))
               ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o_2 (actual rows=1 loops=2)
                     Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)))
               ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o_3 (never executed)
                     Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)))
(13 rows)

-- test startup and runtime exclusion together
:PREFIX SELECT *
FROM generate_series('2000-01-01'::timestamptz,'2000-01-03','1d') AS g(time)
LEFT OUTER JOIN LATERAL(
  SELECT * FROM ordered_append o
    WHERE o.time >= g.time AND o.time < g.time + '1d'::interval AND o.time < now() ORDER BY time DESC LIMIT 1
) l ON true;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join (actual rows=3 loops=1)
   ->  Function Scan on generate_series g (actual rows=3 loops=1)
   ->  Limit (actual rows=1 loops=3)
         ->  Custom Scan (ChunkAppend) (actual rows=1 loops=3)
               Hypertable: ordered_append
               Chunks excluded during startup: 0
               Chunks excluded during runtime: 2
               ->  Index Scan using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o_1 (never executed)
                     Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)) AND ("time" < now()))
               ->  Index Scan using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o_2 (never executed)
                     Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)) AND ("time" < now()))
               ->  Index Scan using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o_3 (actual rows=1 loops=3)
                     Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)) AND ("time" < now()))
(13 rows)

-- test startup and runtime exclusion together
-- all chunks should be filtered
:PREFIX SELECT *
FROM generate_series('2000-01-01'::timestamptz,'2000-01-03','1d') AS g(time)
LEFT OUTER JOIN LATERAL(
  SELECT * FROM ordered_append o
    WHERE o.time >= g.time AND o.time < g.time + '1d'::interval AND o.time > now() ORDER BY time DESC LIMIT 1
) l ON true;
                            QUERY PLAN                            
------------------------------------------------------------------
 Nested Loop Left Join (actual rows=3 loops=1)
   ->  Function Scan on generate_series g (actual rows=3 loops=1)
   ->  Limit (actual rows=0 loops=3)
         ->  Custom Scan (ChunkAppend) (actual rows=0 loops=3)
               Hypertable: ordered_append
               Chunks excluded during startup: 3
               Chunks excluded during runtime: 0
(7 rows)

-- test CTE
-- no chunk exclusion for CTE because cte query is not pulled up
:PREFIX WITH cte AS (SELECT * FROM ordered_append ORDER BY time)
SELECT * FROM cte WHERE time < '2000-02-01'::timestamptz;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 CTE Scan on cte (actual rows=73443 loops=1)
   Filter: ("time" < 'Tue Feb 01 00:00:00 2000 PST'::timestamp with time zone)
   CTE cte
     ->  Custom Scan (ChunkAppend) (actual rows=73443 loops=1)
           Hypertable: ordered_append
           ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=20160 loops=1)
           ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (actual rows=30240 loops=1)
           ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=23043 loops=1)
(8 rows)

-- test JOIN
-- no exclusion on joined table because quals are not propagated yet
:PREFIX SELECT *
FROM ordered_append o1
INNER JOIN ordered_append o2 ON o1.time = o2.time
WHERE o1.time < '2000-02-01'
ORDER BY o1.time;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join (actual rows=220329 loops=1)
   Merge Cond: (o1."time" = o2."time")
   ->  Custom Scan (ChunkAppend) (actual rows=73443 loops=1)
         Hypertable: ordered_append
         ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o1_1 (actual rows=20160 loops=1)
               Index Cond: ("time" < 'Tue Feb 01 00:00:00 2000 PST'::timestamp with time zone)
         ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o1_2 (actual rows=30240 loops=1)
               Index Cond: ("time" < 'Tue Feb 01 00:00:00 2000 PST'::timestamp with time zone)
         ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o1_3 (actual rows=23043 loops=1)
               Index Cond: ("time" < 'Tue Feb 01 00:00:00 2000 PST'::timestamp with time zone)
   ->  Materialize (actual rows=220327 loops=1)
         ->  Custom Scan (ChunkAppend) (actual rows=73443 loops=1)
               Hypertable: ordered_append
               ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o2_1 (actual rows=20160 loops=1)
               ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o2_2 (actual rows=30240 loops=1)
               ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o2_3 (actual rows=23043 loops=1)
(16 rows)

-- test JOIN
-- last chunk of o2 should not be executed
:PREFIX SELECT *
FROM ordered_append o1
INNER JOIN (SELECT * FROM ordered_append o2 ORDER BY time) o2 ON o1.time = o2.time
WHERE o1.time < '2000-01-08'
ORDER BY o1.time;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join (actual rows=90720 loops=1)
   Merge Cond: (o1."time" = o2."time")
   ->  Custom Scan (ChunkAppend) (actual rows=30240 loops=1)
         Hypertable: ordered_append
         ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o1_1 (actual rows=20160 loops=1)
               Index Cond: ("time" < 'Sat Jan 08 00:00:00 2000 PST'::timestamp with time zone)
         ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o1_2 (actual rows=10080 loops=1)
               Index Cond: ("time" < 'Sat Jan 08 00:00:00 2000 PST'::timestamp with time zone)
   ->  Materialize (actual rows=90721 loops=1)
         ->  Custom Scan (ChunkAppend) (actual rows=30241 loops=1)
               Hypertable: ordered_append
               ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o2_1 (actual rows=20160 loops=1)
               ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o2_2 (actual rows=10081 loops=1)
               ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o2_3 (never executed)
(14 rows)

-- test subquery
-- not ChunkAppend so no chunk exclusion
:PREFIX SELECT *
FROM ordered_append WHERE time = (SELECT max(time) FROM ordered_append) ORDER BY time;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Append (actual rows=3 loops=1)
   InitPlan 2 (returns $1)
     ->  Result (actual rows=1 loops=1)
           InitPlan 1 (returns $0)
             ->  Limit (actual rows=1 loops=1)
                   ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
                         Hypertable: ordered_append
                         ->  Index Only Scan using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk _hyper_1_3_chunk_1 (actual rows=1 loops=1)
                               Index Cond: ("time" IS NOT NULL)
                               Heap Fetches: 1
                         ->  Index Only Scan using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk _hyper_1_2_chunk_1 (never executed)
                               Index Cond: ("time" IS NOT NULL)
                               Heap Fetches: 0
                         ->  Index Only Scan using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk _hyper_1_1_chunk_1 (never executed)
                               Index Cond: ("time" IS NOT NULL)
                               Heap Fetches: 0
   ->  Index Scan using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=0 loops=1)
         Index Cond: ("time" = $1)
   ->  Index Scan using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (actual rows=0 loops=1)
         Index Cond: ("time" = $1)
   ->  Index Scan using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=3 loops=1)
         Index Cond: ("time" = $1)
(22 rows)

-- test join against max query
-- not ChunkAppend so no chunk exclusion
:PREFIX SELECT *
FROM ordered_append o1 INNER JOIN (SELECT max(time) AS max_time FROM ordered_append) o2 ON o1.time = o2.max_time ORDER BY time;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Sort (actual rows=3 loops=1)
   Sort Key: o1."time"
   Sort Method: quicksort  Memory: 25kB
   ->  Nested Loop (actual rows=3 loops=1)
         ->  Result (actual rows=1 loops=1)
               InitPlan 1 (returns $0)
                 ->  Limit (actual rows=1 loops=1)
                       ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
                             Hypertable: ordered_append
                             ->  Index Only Scan using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
                                   Index Cond: ("time" IS NOT NULL)
                                   Heap Fetches: 1
                             ->  Index Only Scan using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
                                   Index Cond: ("time" IS NOT NULL)
                                   Heap Fetches: 0
                             ->  Index Only Scan using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (never executed)
                                   Index Cond: ("time" IS NOT NULL)
                                   Heap Fetches: 0
         ->  Append (actual rows=3 loops=1)
               ->  Index Scan using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o1 (actual rows=0 loops=1)
                     Index Cond: ("time" = ($0))
               ->  Index Scan using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o1_1 (actual rows=0 loops=1)
                     Index Cond: ("time" = ($0))
               ->  Index Scan using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o1_2 (actual rows=3 loops=1)
                     Index Cond: ("time" = ($0))
(25 rows)

-- test ordered append with limit expression
:PREFIX SELECT *
FROM ordered_append ORDER BY time LIMIT (SELECT length('four'));
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=4 loops=1)
   InitPlan 1 (returns $0)
     ->  Result (actual rows=1 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=4 loops=1)
         Hypertable: ordered_append
         ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=4 loops=1)
         ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
         ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (never executed)
(8 rows)

-- test with ordered guc disabled
SET timescaledb.enable_ordered_append TO off;
:PREFIX SELECT *
FROM ordered_append ORDER BY time LIMIT 3;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=3 loops=1)
   ->  Merge Append (actual rows=3 loops=1)
         Sort Key: _hyper_1_1_chunk."time"
         ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=3 loops=1)
         ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (actual rows=1 loops=1)
         ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
(6 rows)

RESET timescaledb.enable_ordered_append;
:PREFIX SELECT *
FROM ordered_append ORDER BY time LIMIT 3;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=3 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=3 loops=1)
         Hypertable: ordered_append
         ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=3 loops=1)
         ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
         ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (never executed)
(6 rows)

-- test with chunk append disabled
SET timescaledb.enable_chunk_append TO off;
:PREFIX SELECT *
FROM ordered_append ORDER BY time LIMIT 3;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=3 loops=1)
   ->  Merge Append (actual rows=3 loops=1)
         Sort Key: _hyper_1_1_chunk."time"
         ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=3 loops=1)
         ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (actual rows=1 loops=1)
         ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
(6 rows)

RESET timescaledb.enable_chunk_append;
:PREFIX SELECT *
FROM ordered_append ORDER BY time LIMIT 3;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=3 loops=1)
   ->  Custom Scan (ChunkAppend) (actual rows=3 loops=1)
         Hypertable: ordered_append
         ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk (actual rows=3 loops=1)
         ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk (never executed)
         ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk (never executed)
(6 rows)

-- test space partitioning with startup exclusion
:PREFIX SELECT *
FROM space WHERE time < now() ORDER BY time;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ChunkAppend) (actual rows=77766 loops=1)
   Hypertable: space
   ->  Merge Append (actual rows=40320 loops=1)
         Sort Key: _hyper_7_24_chunk."time"
         ->  Index Scan Backward using _hyper_7_24_chunk_space_time_idx on _hyper_7_24_chunk (actual rows=6720 loops=1)
               Index Cond: ("time" < now())
         ->  Index Scan Backward using _hyper_7_26_chunk_space_time_idx on _hyper_7_26_chunk (actual rows=13440 loops=1)
               Index Cond: ("time" < now())
         ->  Index Scan Backward using _hyper_7_28_chunk_space_time_idx on _hyper_7_28_chunk (actual rows=6720 loops=1)
               Index Cond: ("time" < now())
         ->  Index Scan Backward using _hyper_7_30_chunk_space_time_idx on _hyper_7_30_chunk (actual rows=13440 loops=1)
               Index Cond: ("time" < now())
   ->  Merge Append (actual rows=37446 loops=1)
         Sort Key: _hyper_7_23_chunk."time"
         ->  Index Scan Backward using _hyper_7_23_chunk_space_time_idx on _hyper_7_23_chunk (actual rows=6241 loops=1)
               Index Cond: ("time" < now())
         ->  Index Scan Backward using _hyper_7_25_chunk_space_time_idx on _hyper_7_25_chunk (actual rows=12482 loops=1)
               Index Cond: ("time" < now())
         ->  Index Scan Backward using _hyper_7_27_chunk_space_time_idx on _hyper_7_27_chunk (actual rows=6241 loops=1)
               Index Cond: ("time" < now())
         ->  Index Scan Backward using _hyper_7_29_chunk_space_time_idx on _hyper_7_29_chunk (actual rows=12482 loops=1)
               Index Cond: ("time" < now())
(22 rows)

-- test runtime exclusion together with space partitioning
:PREFIX SELECT *
FROM generate_series('2000-01-01'::timestamptz,'2000-01-03','1d') AS g(time)
LEFT OUTER JOIN LATERAL(
  SELECT * FROM space o
    WHERE o.time >= g.time AND o.time < g.time + '1d'::interval ORDER BY time DESC LIMIT 1
) l ON true;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join (actual rows=3 loops=1)
   ->  Function Scan on generate_series g (actual rows=3 loops=1)
   ->  Limit (actual rows=1 loops=3)
         ->  Custom Scan (ChunkAppend) (actual rows=1 loops=3)
               Hypertable: space
               ->  Merge Append (actual rows=0 loops=3)
                     Sort Key: o_1."time" DESC
                     ->  Index Scan using _hyper_7_23_chunk_space_time_idx on _hyper_7_23_chunk o_1 (actual rows=0 loops=3)
                           Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)))
                     ->  Index Scan using _hyper_7_25_chunk_space_time_idx on _hyper_7_25_chunk o_2 (actual rows=0 loops=3)
                           Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)))
                     ->  Index Scan using _hyper_7_27_chunk_space_time_idx on _hyper_7_27_chunk o_3 (actual rows=0 loops=3)
                           Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)))
                     ->  Index Scan using _hyper_7_29_chunk_space_time_idx on _hyper_7_29_chunk o_4 (actual rows=0 loops=3)
                           Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)))
               ->  Merge Append (actual rows=1 loops=3)
                     Sort Key: o_5."time" DESC
                     ->  Index Scan using _hyper_7_24_chunk_space_time_idx on _hyper_7_24_chunk o_5 (actual rows=1 loops=3)
                           Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)))
                     ->  Index Scan using _hyper_7_26_chunk_space_time_idx on _hyper_7_26_chunk o_6 (actual rows=1 loops=3)
                           Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)))
                     ->  Index Scan using _hyper_7_28_chunk_space_time_idx on _hyper_7_28_chunk o_7 (actual rows=1 loops=3)
                           Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)))
                     ->  Index Scan using _hyper_7_30_chunk_space_time_idx on _hyper_7_30_chunk o_8 (actual rows=1 loops=3)
                           Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)))
(25 rows)

-- test startup and runtime exclusion together with space partitioning
:PREFIX SELECT *
FROM generate_series('2000-01-01'::timestamptz,'2000-01-03','1d') AS g(time)
LEFT OUTER JOIN LATERAL(
  SELECT * FROM space o
    WHERE o.time >= g.time AND o.time < g.time + '1d'::interval AND o.time < now() ORDER BY time DESC LIMIT 1
) l ON true;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join (actual rows=3 loops=1)
   ->  Function Scan on generate_series g (actual rows=3 loops=1)
   ->  Limit (actual rows=1 loops=3)
         ->  Custom Scan (ChunkAppend) (actual rows=1 loops=3)
               Hypertable: space
               ->  Merge Append (actual rows=0 loops=3)
                     Sort Key: o_1."time" DESC
                     ->  Index Scan using _hyper_7_23_chunk_space_time_idx on _hyper_7_23_chunk o_1 (actual rows=0 loops=3)
                           Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)) AND ("time" < now()))
                     ->  Index Scan using _hyper_7_25_chunk_space_time_idx on _hyper_7_25_chunk o_2 (actual rows=0 loops=3)
                           Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)) AND ("time" < now()))
                     ->  Index Scan using _hyper_7_27_chunk_space_time_idx on _hyper_7_27_chunk o_3 (actual rows=0 loops=3)
                           Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)) AND ("time" < now()))
                     ->  Index Scan using _hyper_7_29_chunk_space_time_idx on _hyper_7_29_chunk o_4 (actual rows=0 loops=3)
                           Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)) AND ("time" < now()))
               ->  Merge Append (actual rows=1 loops=3)
                     Sort Key: o_5."time" DESC
                     ->  Index Scan using _hyper_7_24_chunk_space_time_idx on _hyper_7_24_chunk o_5 (actual rows=1 loops=3)
                           Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)) AND ("time" < now()))
                     ->  Index Scan using _hyper_7_26_chunk_space_time_idx on _hyper_7_26_chunk o_6 (actual rows=1 loops=3)
                           Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)) AND ("time" < now()))
                     ->  Index Scan using _hyper_7_28_chunk_space_time_idx on _hyper_7_28_chunk o_7 (actual rows=1 loops=3)
                           Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)) AND ("time" < now()))
                     ->  Index Scan using _hyper_7_30_chunk_space_time_idx on _hyper_7_30_chunk o_8 (actual rows=1 loops=3)
                           Index Cond: (("time" >= g."time") AND ("time" < (g."time" + '@ 1 day'::interval)) AND ("time" < now()))
(25 rows)

-- test JOIN on time column
-- should use 2 ChunkAppend
:PREFIX SELECT * FROM ordered_append o1 INNER JOIN ordered_append o2 ON o1.time = o2.time ORDER BY o1.time LIMIT 100;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=100 loops=1)
   ->  Merge Join (actual rows=100 loops=1)
         Merge Cond: (o1."time" = o2."time")
         ->  Custom Scan (ChunkAppend) (actual rows=34 loops=1)
               Hypertable: ordered_append
               ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o1_1 (actual rows=34 loops=1)
               ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o1_2 (never executed)
               ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o1_3 (never executed)
         ->  Materialize (actual rows=100 loops=1)
               ->  Custom Scan (ChunkAppend) (actual rows=34 loops=1)
                     Hypertable: ordered_append
                     ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o2_1 (actual rows=34 loops=1)
                     ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o2_2 (never executed)
                     ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o2_3 (never executed)
(14 rows)

-- test JOIN on time column with ON clause expression order switched
-- should use 2 ChunkAppend
:PREFIX SELECT * FROM ordered_append o1 INNER JOIN ordered_append o2 ON o2.time = o1.time ORDER BY o1.time LIMIT 100;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=100 loops=1)
   ->  Merge Join (actual rows=100 loops=1)
         Merge Cond: (o1."time" = o2."time")
         ->  Custom Scan (ChunkAppend) (actual rows=34 loops=1)
               Hypertable: ordered_append
               ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o1_1 (actual rows=34 loops=1)
               ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o1_2 (never executed)
               ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o1_3 (never executed)
         ->  Materialize (actual rows=100 loops=1)
               ->  Custom Scan (ChunkAppend) (actual rows=34 loops=1)
                     Hypertable: ordered_append
                     ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o2_1 (actual rows=34 loops=1)
                     ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o2_2 (never executed)
                     ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o2_3 (never executed)
(14 rows)

-- test JOIN on time column with equality condition in WHERE clause
-- should use 2 ChunkAppend
:PREFIX SELECT * FROM ordered_append o1 INNER JOIN ordered_append o2 ON true WHERE o1.time = o2.time ORDER BY o1.time LIMIT 100;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=100 loops=1)
   ->  Merge Join (actual rows=100 loops=1)
         Merge Cond: (o1."time" = o2."time")
         ->  Custom Scan (ChunkAppend) (actual rows=34 loops=1)
               Hypertable: ordered_append
               ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o1_1 (actual rows=34 loops=1)
               ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o1_2 (never executed)
               ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o1_3 (never executed)
         ->  Materialize (actual rows=100 loops=1)
               ->  Custom Scan (ChunkAppend) (actual rows=34 loops=1)
                     Hypertable: ordered_append
                     ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o2_1 (actual rows=34 loops=1)
                     ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o2_2 (never executed)
                     ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o2_3 (never executed)
(14 rows)

-- test JOIN on time column with ORDER BY 2nd hypertable
-- should use 2 ChunkAppend
:PREFIX SELECT * FROM ordered_append o1 INNER JOIN ordered_append o2 ON o1.time = o2.time ORDER BY o2.time LIMIT 100;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=100 loops=1)
   ->  Merge Join (actual rows=100 loops=1)
         Merge Cond: (o1."time" = o2."time")
         ->  Custom Scan (ChunkAppend) (actual rows=34 loops=1)
               Hypertable: ordered_append
               ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o1_1 (actual rows=34 loops=1)
               ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o1_2 (never executed)
               ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o1_3 (never executed)
         ->  Materialize (actual rows=100 loops=1)
               ->  Custom Scan (ChunkAppend) (actual rows=34 loops=1)
                     Hypertable: ordered_append
                     ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o2_1 (actual rows=34 loops=1)
                     ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o2_2 (never executed)
                     ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o2_3 (never executed)
(14 rows)

-- test JOIN on time column and device_id
-- should use 2 ChunkAppend
:PREFIX SELECT * FROM ordered_append o1 INNER JOIN ordered_append o2 ON o1.device_id = o2.device_id AND o1.time = o2.time ORDER BY o1.time LIMIT 100;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=100 loops=1)
   ->  Merge Join (actual rows=100 loops=1)
         Merge Cond: (o1."time" = o2."time")
         Join Filter: (o1.device_id = o2.device_id)
         Rows Removed by Join Filter: 198
         ->  Custom Scan (ChunkAppend) (actual rows=100 loops=1)
               Hypertable: ordered_append
               ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o1_1 (actual rows=100 loops=1)
               ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o1_2 (never executed)
               ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o1_3 (never executed)
         ->  Materialize (actual rows=298 loops=1)
               ->  Custom Scan (ChunkAppend) (actual rows=100 loops=1)
                     Hypertable: ordered_append
                     ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o2_1 (actual rows=100 loops=1)
                     ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o2_2 (never executed)
                     ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o2_3 (never executed)
(16 rows)

-- test JOIN on device_id
-- should not use ordered append for 2nd hypertable
:PREFIX SELECT * FROM ordered_append o1 INNER JOIN ordered_append o2 ON o1.device_id = o2.device_id ORDER BY o1.time LIMIT 100;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=100 loops=1)
   ->  Nested Loop (actual rows=100 loops=1)
         ->  Custom Scan (ChunkAppend) (actual rows=1 loops=1)
               Hypertable: ordered_append
               ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o1_1 (actual rows=1 loops=1)
               ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o1_2 (never executed)
               ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o1_3 (never executed)
         ->  Append (actual rows=100 loops=1)
               ->  Index Scan using _hyper_1_1_chunk_ordered_append_device_id_time_idx on _hyper_1_1_chunk o2 (actual rows=100 loops=1)
                     Index Cond: (device_id = o1.device_id)
               ->  Index Scan using _hyper_1_2_chunk_ordered_append_device_id_time_idx on _hyper_1_2_chunk o2_1 (never executed)
                     Index Cond: (device_id = o1.device_id)
               ->  Index Scan using _hyper_1_3_chunk_ordered_append_device_id_time_idx on _hyper_1_3_chunk o2_2 (never executed)
                     Index Cond: (device_id = o1.device_id)
(14 rows)

-- test JOIN on time column with implicit join
-- should use 2 ChunkAppend
:PREFIX SELECT * FROM ordered_append o1, ordered_append o2 WHERE o1.time = o2.time ORDER BY o1.time LIMIT 100;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=100 loops=1)
   ->  Merge Join (actual rows=100 loops=1)
         Merge Cond: (o1."time" = o2."time")
         ->  Custom Scan (ChunkAppend) (actual rows=34 loops=1)
               Hypertable: ordered_append
               ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o1_1 (actual rows=34 loops=1)
               ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o1_2 (never executed)
               ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o1_3 (never executed)
         ->  Materialize (actual rows=100 loops=1)
               ->  Custom Scan (ChunkAppend) (actual rows=34 loops=1)
                     Hypertable: ordered_append
                     ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o2_1 (actual rows=34 loops=1)
                     ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o2_2 (never executed)
                     ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o2_3 (never executed)
(14 rows)

-- test JOIN on time column with 3 hypertables
-- should use 3 ChunkAppend
:PREFIX SELECT * FROM ordered_append o1 INNER JOIN ordered_append o2 ON o1.time = o2.time INNER JOIN ordered_append o3 ON o1.time = o3.time ORDER BY o1.time LIMIT 100;
                                                                        QUERY PLAN                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=100 loops=1)
   ->  Merge Join (actual rows=100 loops=1)
         Merge Cond: (o3."time" = o1."time")
         ->  Custom Scan (ChunkAppend) (actual rows=12 loops=1)
               Hypertable: ordered_append
               ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o3_1 (actual rows=12 loops=1)
               ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o3_2 (never executed)
               ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o3_3 (never executed)
         ->  Materialize (actual rows=100 loops=1)
               ->  Merge Join (actual rows=37 loops=1)
                     Merge Cond: (o1."time" = o2."time")
                     ->  Custom Scan (ChunkAppend) (actual rows=13 loops=1)
                           Hypertable: ordered_append
                           ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o1_1 (actual rows=13 loops=1)
                           ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o1_2 (never executed)
                           ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o1_3 (never executed)
                     ->  Materialize (actual rows=37 loops=1)
                           ->  Custom Scan (ChunkAppend) (actual rows=13 loops=1)
                                 Hypertable: ordered_append
                                 ->  Index Scan Backward using _hyper_1_1_chunk_ordered_append_time_idx on _hyper_1_1_chunk o2_1 (actual rows=13 loops=1)
                                 ->  Index Scan Backward using _hyper_1_2_chunk_ordered_append_time_idx on _hyper_1_2_chunk o2_2 (never executed)
                                 ->  Index Scan Backward using _hyper_1_3_chunk_ordered_append_time_idx on _hyper_1_3_chunk o2_3 (never executed)
(22 rows)

-- test with space partitioning
:PREFIX SELECT * FROM space s1 INNER JOIN space s2 ON s1.time = s2.time ORDER BY s1.time LIMIT 100;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=100 loops=1)
   ->  Merge Join (actual rows=100 loops=1)
         Merge Cond: (s1."time" = s2."time")
         ->  Custom Scan (ChunkAppend) (actual rows=17 loops=1)
               Hypertable: space
               ->  Merge Append (actual rows=17 loops=1)
                     Sort Key: s1_1."time"
                     ->  Index Scan Backward using _hyper_7_24_chunk_space_time_idx on _hyper_7_24_chunk s1_1 (actual rows=3 loops=1)
                     ->  Index Scan Backward using _hyper_7_26_chunk_space_time_idx on _hyper_7_26_chunk s1_2 (actual rows=7 loops=1)
                     ->  Index Scan Backward using _hyper_7_28_chunk_space_time_idx on _hyper_7_28_chunk s1_3 (actual rows=3 loops=1)
                     ->  Index Scan Backward using _hyper_7_30_chunk_space_time_idx on _hyper_7_30_chunk s1_4 (actual rows=7 loops=1)
               ->  Merge Append (never executed)
                     Sort Key: s1_5."time"
                     ->  Index Scan Backward using _hyper_7_23_chunk_space_time_idx on _hyper_7_23_chunk s1_5 (never executed)
                     ->  Index Scan Backward using _hyper_7_25_chunk_space_time_idx on _hyper_7_25_chunk s1_6 (never executed)
                     ->  Index Scan Backward using _hyper_7_27_chunk_space_time_idx on _hyper_7_27_chunk s1_7 (never executed)
                     ->  Index Scan Backward using _hyper_7_29_chunk_space_time_idx on _hyper_7_29_chunk s1_8 (never executed)
         ->  Materialize (actual rows=100 loops=1)
               ->  Custom Scan (ChunkAppend) (actual rows=19 loops=1)
                     Hypertable: space
                     ->  Merge Append (actual rows=19 loops=1)
                           Sort Key: s2_1."time"
                           ->  Index Scan Backward using _hyper_7_24_chunk_space_time_idx on _hyper_7_24_chunk s2_1 (actual rows=4 loops=1)
                           ->  Index Scan Backward using _hyper_7_26_chunk_space_time_idx on _hyper_7_26_chunk s2_2 (actual rows=7 loops=1)
                           ->  Index Scan Backward using _hyper_7_28_chunk_space_time_idx on _hyper_7_28_chunk s2_3 (actual rows=4 loops=1)
                           ->  Index Scan Backward using _hyper_7_30_chunk_space_time_idx on _hyper_7_30_chunk s2_4 (actual rows=7 loops=1)
                     ->  Merge Append (never executed)
                           Sort Key: s2_5."time"
                           ->  Index Scan Backward using _hyper_7_23_chunk_space_time_idx on _hyper_7_23_chunk s2_5 (never executed)
                           ->  Index Scan Backward using _hyper_7_25_chunk_space_time_idx on _hyper_7_25_chunk s2_6 (never executed)
                           ->  Index Scan Backward using _hyper_7_27_chunk_space_time_idx on _hyper_7_27_chunk s2_7 (never executed)
                           ->  Index Scan Backward using _hyper_7_29_chunk_space_time_idx on _hyper_7_29_chunk s2_8 (never executed)
(32 rows)

--generate the results into two different files
\set ECHO errors
